
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

theory Enum__bool_aux

  use why3.Bool.Bool 
  
  function max  : int = (1)
  
  function min  : int = (0)
  
end

theory Enum__bool

  use why3.Bool.Bool 
  
  use import Enum__bool_aux 
  
  clone export enum.Enum with constant min = min, constant max = max
  
end

module Unsafe_enum__bool

  use why3.Bool.Bool 
  
  use import Enum__bool 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_enum__bool

  use why3.Bool.Bool 
  
  use import Enum__bool 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

module Root_unsigned_intP_safe

  use why3.Bool.Bool 
  
end

module Root_unsigned_intP_unsafe

  use why3.Bool.Bool 
  
end

theory Root_unsigned_intP

  use why3.Bool.Bool 
  
  type unsigned_intP 
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

theory Axiomatic_Ctype

  use enum.Int8 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function tolower int : int
  
  
  axiom A #"/home/work/workspace/self/verker/ctype.h" 59 13 32#
  "expl:Axiom a" :
  (#"/home/work/workspace/self/verker/ctype.h" 59 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 65 20 32#
  "expl:Integer cast" (Int8.of_int (65)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 65 50 62#
  "expl:Integer cast" (Int8.of_int (97))))))
  
  axiom B #"/home/work/workspace/self/verker/ctype.h" 59 43 62#
  "expl:Axiom b" :
  (#"/home/work/workspace/self/verker/ctype.h" 59 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 68 20 32#
  "expl:Integer cast" (Int8.of_int (66)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 68 50 62#
  "expl:Integer cast" (Int8.of_int (98))))))
  
  axiom C_13 #"/home/work/workspace/self/verker/ctype.h" 59 73 92#
  "expl:Axiom c" :
  (#"/home/work/workspace/self/verker/ctype.h" 59 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 71 20 32#
  "expl:Integer cast" (Int8.of_int (67)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 71 50 62#
  "expl:Integer cast" (Int8.of_int (99))))))
  
  axiom D #"/home/work/workspace/self/verker/ctype.h" 60 13 32#
  "expl:Axiom d" :
  (#"/home/work/workspace/self/verker/ctype.h" 60 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 74 20 32#
  "expl:Integer cast" (Int8.of_int (68)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 74 50 63#
  "expl:Integer cast" (Int8.of_int (100))))))
  
  axiom E #"/home/work/workspace/self/verker/ctype.h" 60 43 62#
  "expl:Axiom e" :
  (#"/home/work/workspace/self/verker/ctype.h" 60 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 77 20 32#
  "expl:Integer cast" (Int8.of_int (69)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 77 50 63#
  "expl:Integer cast" (Int8.of_int (101))))))
  
  axiom F #"/home/work/workspace/self/verker/ctype.h" 60 73 92#
  "expl:Axiom f" :
  (#"/home/work/workspace/self/verker/ctype.h" 60 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 80 20 32#
  "expl:Integer cast" (Int8.of_int (70)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 80 50 63#
  "expl:Integer cast" (Int8.of_int (102))))))
  
  axiom G #"/home/work/workspace/self/verker/ctype.h" 61 13 32#
  "expl:Axiom g" :
  (#"/home/work/workspace/self/verker/ctype.h" 61 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 83 20 32#
  "expl:Integer cast" (Int8.of_int (71)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 83 50 63#
  "expl:Integer cast" (Int8.of_int (103))))))
  
  axiom H #"/home/work/workspace/self/verker/ctype.h" 61 43 62#
  "expl:Axiom h" :
  (#"/home/work/workspace/self/verker/ctype.h" 61 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 86 20 32#
  "expl:Integer cast" (Int8.of_int (72)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 86 50 63#
  "expl:Integer cast" (Int8.of_int (104))))))
  
  axiom I #"/home/work/workspace/self/verker/ctype.h" 61 73 92#
  "expl:Axiom i" :
  (#"/home/work/workspace/self/verker/ctype.h" 61 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 89 20 32#
  "expl:Integer cast" (Int8.of_int (73)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 89 50 63#
  "expl:Integer cast" (Int8.of_int (105))))))
  
  axiom J #"/home/work/workspace/self/verker/ctype.h" 62 13 32#
  "expl:Axiom j" :
  (#"/home/work/workspace/self/verker/ctype.h" 62 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 92 21 33#
  "expl:Integer cast" (Int8.of_int (74)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 92 51 64#
  "expl:Integer cast" (Int8.of_int (106))))))
  
  axiom K #"/home/work/workspace/self/verker/ctype.h" 62 43 62#
  "expl:Axiom k" :
  (#"/home/work/workspace/self/verker/ctype.h" 62 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 95 21 33#
  "expl:Integer cast" (Int8.of_int (75)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 95 51 64#
  "expl:Integer cast" (Int8.of_int (107))))))
  
  axiom L #"/home/work/workspace/self/verker/ctype.h" 62 73 92#
  "expl:Axiom l" :
  (#"/home/work/workspace/self/verker/ctype.h" 62 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 98 21 33#
  "expl:Integer cast" (Int8.of_int (76)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 98 51 64#
  "expl:Integer cast" (Int8.of_int (108))))))
  
  axiom M #"/home/work/workspace/self/verker/ctype.h" 63 13 32#
  "expl:Axiom m" :
  (#"/home/work/workspace/self/verker/ctype.h" 63 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 101 21 33#
  "expl:Integer cast" (Int8.of_int (77)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 101 51 64#
  "expl:Integer cast" (Int8.of_int (109))))))
  
  axiom N #"/home/work/workspace/self/verker/ctype.h" 63 43 62#
  "expl:Axiom n" :
  (#"/home/work/workspace/self/verker/ctype.h" 63 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 104 21 33#
  "expl:Integer cast" (Int8.of_int (78)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 104 51 64#
  "expl:Integer cast" (Int8.of_int (110))))))
  
  axiom O #"/home/work/workspace/self/verker/ctype.h" 63 73 92#
  "expl:Axiom o" :
  (#"/home/work/workspace/self/verker/ctype.h" 63 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 107 21 33#
  "expl:Integer cast" (Int8.of_int (79)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 107 51 64#
  "expl:Integer cast" (Int8.of_int (111))))))
  
  axiom P #"/home/work/workspace/self/verker/ctype.h" 64 13 32#
  "expl:Axiom p" :
  (#"/home/work/workspace/self/verker/ctype.h" 64 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 110 21 33#
  "expl:Integer cast" (Int8.of_int (80)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 110 51 64#
  "expl:Integer cast" (Int8.of_int (112))))))
  
  axiom Q #"/home/work/workspace/self/verker/ctype.h" 64 43 62#
  "expl:Axiom q" :
  (#"/home/work/workspace/self/verker/ctype.h" 64 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 113 21 33#
  "expl:Integer cast" (Int8.of_int (81)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 113 51 64#
  "expl:Integer cast" (Int8.of_int (113))))))
  
  axiom R #"/home/work/workspace/self/verker/ctype.h" 64 73 92#
  "expl:Axiom r" :
  (#"/home/work/workspace/self/verker/ctype.h" 64 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 116 21 33#
  "expl:Integer cast" (Int8.of_int (82)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 116 51 64#
  "expl:Integer cast" (Int8.of_int (114))))))
  
  axiom S_3 #"/home/work/workspace/self/verker/ctype.h" 65 13 32#
  "expl:Axiom s" :
  (#"/home/work/workspace/self/verker/ctype.h" 65 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 119 21 33#
  "expl:Integer cast" (Int8.of_int (83)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 119 51 64#
  "expl:Integer cast" (Int8.of_int (115))))))
  
  axiom T #"/home/work/workspace/self/verker/ctype.h" 65 43 62#
  "expl:Axiom t" :
  (#"/home/work/workspace/self/verker/ctype.h" 65 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 122 21 33#
  "expl:Integer cast" (Int8.of_int (84)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 122 51 64#
  "expl:Integer cast" (Int8.of_int (116))))))
  
  axiom U #"/home/work/workspace/self/verker/ctype.h" 65 73 92#
  "expl:Axiom u" :
  (#"/home/work/workspace/self/verker/ctype.h" 65 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 125 21 33#
  "expl:Integer cast" (Int8.of_int (85)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 125 51 64#
  "expl:Integer cast" (Int8.of_int (117))))))
  
  axiom V #"/home/work/workspace/self/verker/ctype.h" 66 13 32#
  "expl:Axiom v" :
  (#"/home/work/workspace/self/verker/ctype.h" 66 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 128 21 33#
  "expl:Integer cast" (Int8.of_int (86)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 128 51 64#
  "expl:Integer cast" (Int8.of_int (118))))))
  
  axiom W #"/home/work/workspace/self/verker/ctype.h" 66 43 62#
  "expl:Axiom w" :
  (#"/home/work/workspace/self/verker/ctype.h" 66 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 131 21 33#
  "expl:Integer cast" (Int8.of_int (87)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 131 51 64#
  "expl:Integer cast" (Int8.of_int (119))))))
  
  axiom X #"/home/work/workspace/self/verker/ctype.h" 66 73 92#
  "expl:Axiom x" :
  (#"/home/work/workspace/self/verker/ctype.h" 66 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 134 21 33#
  "expl:Integer cast" (Int8.of_int (88)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 134 51 64#
  "expl:Integer cast" (Int8.of_int (120))))))
  
  axiom Y #"/home/work/workspace/self/verker/ctype.h" 67 13 32#
  "expl:Axiom y" :
  (#"/home/work/workspace/self/verker/ctype.h" 67 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 137 21 33#
  "expl:Integer cast" (Int8.of_int (89)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 137 51 64#
  "expl:Integer cast" (Int8.of_int (121))))))
  
  axiom Z #"/home/work/workspace/self/verker/ctype.h" 67 43 62#
  "expl:Axiom z" :
  (#"/home/work/workspace/self/verker/ctype.h" 67 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 140 21 33#
  "expl:Integer cast" (Int8.of_int (90)))))
  (Int8.to_int (#"_parse_integer_fixup_radix.jc" 140 51 64#
  "expl:Integer cast" (Int8.of_int (122))))))
  
  predicate isupper (c_0 : int)
  =
     (((<=)
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 31 5 17#
      "expl:Integer cast" (Int8.of_int (65)))) c_0)
     /\
     ((<=) c_0
     (Int8.to_int (#"_parse_integer_fixup_radix.jc" 31 50 62#
     "expl:Integer cast" (Int8.of_int (90))))))
  
  
  axiom Pl #"/home/work/workspace/self/verker/ctype.h" 69 14 64#
  "expl:Axiom pl" :
  (#"/home/work/workspace/self/verker/ctype.h" 69 14 64#
  (forall c_9_0 : int.
   ((not (isupper c_9_0)) -> ((=) (tolower c_9_0) c_9_0))))
  
  predicate islower (c : int)
  =
     (((<=)
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 28 5 17#
      "expl:Integer cast" (Int8.of_int (97)))) c)
     /\
     ((<=) c
     (Int8.to_int (#"_parse_integer_fixup_radix.jc" 28 46 59#
     "expl:Integer cast" (Int8.of_int (122))))))
  
  
  function toupper int : int
  
  
  axiom Pu #"/home/work/workspace/self/verker/ctype.h" 70 14 64#
  "expl:Axiom pu" :
  (#"/home/work/workspace/self/verker/ctype.h" 70 14 64#
  (forall c_10_0 : int.
   ((not (islower c_10_0)) -> ((=) (toupper c_10_0) c_10_0))))
  
  axiom Tl #"/home/work/workspace/self/verker/ctype.h" 71 14 73#
  "expl:Axiom tl" :
  (#"/home/work/workspace/self/verker/ctype.h" 71 14 73#
  (forall c_11_1 : int.
   ((not (islower c_11_1)) -> ((=) (toupper (tolower c_11_1)) c_11_1))))
  
  axiom Tu #"/home/work/workspace/self/verker/ctype.h" 72 14 73#
  "expl:Axiom tu" :
  (#"/home/work/workspace/self/verker/ctype.h" 72 14 73#
  (forall c_12_0 : int.
   ((not (isupper c_12_0)) -> ((=) (tolower (toupper c_12_0)) c_12_0))))
  
  predicate isdigit (c_2 : int)
  =
     (((<=)
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 37 5 17#
      "expl:Integer cast" (Int8.of_int (48)))) c_2)
     /\
     ((<=) c_2
     (Int8.to_int (#"_parse_integer_fixup_radix.jc" 37 50 62#
     "expl:Integer cast" (Int8.of_int (57))))))
  
  
  predicate isxdigit (c_6 : int)
  =
     ((isdigit c_6) \/
     ((((<=)
       (Int8.to_int (#"_parse_integer_fixup_radix.jc" 55 8 20#
       "expl:Integer cast" (Int8.of_int (97)))) c_6)
      /\
      ((<=) c_6
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 56 16 29#
      "expl:Integer cast" (Int8.of_int (102))))))
     \/
     (((<=)
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 57 7 19#
      "expl:Integer cast" (Int8.of_int (65)))) c_6)
     /\
     ((<=) c_6
     (Int8.to_int (#"_parse_integer_fixup_radix.jc" 58 15 27#
     "expl:Integer cast" (Int8.of_int (70))))))))
  
  
  predicate isodigit (c_3 : int)
  =
     (((<=)
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 40 5 17#
      "expl:Integer cast" (Int8.of_int (48)))) c_3)
     /\
     ((<=) c_3
     (Int8.to_int (#"_parse_integer_fixup_radix.jc" 40 50 62#
     "expl:Integer cast" (Int8.of_int (55))))))
  
  
  predicate isalpha (c_1 : int) = ((isupper c_1) \/ (islower c_1))
  
  
  predicate isalnum (c_4 : int) = ((isdigit c_4) \/ (isalpha c_4))
  
  
  predicate isspace (c_5 : int)
  =
     (((=) c_5
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 46 16 28#
      "expl:Integer cast" (Int8.of_int (32)))))
     \/
     (((=) c_5
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 47 17 29#
      "expl:Integer cast" (Int8.of_int (12)))))
     \/
     (((=) c_5
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 48 16 28#
      "expl:Integer cast" (Int8.of_int (10)))))
     \/
     (((=) c_5
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 49 15 27#
      "expl:Integer cast" (Int8.of_int (13)))))
     \/
     (((=) c_5
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 50 14 25#
      "expl:Integer cast" (Int8.of_int (9)))))
     \/
     ((=) c_5
     (Int8.to_int (#"_parse_integer_fixup_radix.jc" 51 13 25#
     "expl:Integer cast" (Int8.of_int (11))))))))))
  
  
end

module Function__tolower_safe

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val _tolower
  (c_1_0 : Int8.t) : Int8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 122 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (tolower (Int8.to_int c_1_0)))) }
  
end

module Function_isxdigit_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isxdigit_0
  (c_10 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 91 12 36#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isxdigit (Int8.to_int c_10)))) }
  
end

module Function__parse_integer_fixup_radix_safety
#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 3 11 73#
"expl:_parse_integer_fixup_radix, safety"

  use enum.Uint32 
  
  use Safe_uint32 
  
  use Safe_int8 
  
  use Safe_int32_of_Safe_int8 
  
  use Safe_int32 
  
  use Safe_enum__bool 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_isxdigit_0_safe 
  
  use Function__tolower_safe 
  
  use why3.Bool.Bool 
  
  let _parse_integer_fixup_radix
  #"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 3 11 73#
  "expl:Function _parse_integer_fixup_radix, safety" =
  fun
   (s_2 : (pointer voidP)) (base : (pointer unsigned_intP))
   (unsigned_intP_unsigned_intM_base_6 : ref (memory unsigned_intP Uint32.t))
   (unsigned_intP_base_6_alloc_table : (alloc_table unsigned_intP))
   (voidP_s_5_alloc_table : (alloc_table voidP)) (voidP_s_5_tag_table :
   (tag_table voidP)) (charP_charM_s_5 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_s_5_alloc_table s_2) ->
     (((=) (typeof voidP_s_5_tag_table s_2) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_5_alloc_table s_2) i) /\
       ((<) i (offset_max voidP_s_5_alloc_table s_2))) ->
       ((=) (typeof voidP_s_5_tag_table (shift s_2 i)) charP_tag)))))
   /\
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 13 13 29#
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409#
     ((<=) (offset_min voidP_s_5_alloc_table s_2) (0)))
    /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409#
     ((>=) (offset_max voidP_s_5_alloc_table s_2) (2)))
    /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)) /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)) /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)))))))))))
   /\
   (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 14 13 25#
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((<=) (offset_min unsigned_intP_base_6_alloc_table base) (0)))
   /\
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((>=) (offset_max unsigned_intP_base_6_alloc_table base) (0)))
   /\ (#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true))))))))))
   } ensures { ("expl:Postcondition" true) }  ->
   (let mutable_s_2 = ref s_2 in
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (let tmp = ref (Safe_int8.any_  () ) in
    (let tmp_0 = ref (Safe_enum__bool.any_  () ) in
    (let tmp_1 = ref (Safe_int8.any_  () ) in
    begin
    (if
    (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 5 5 15#
    (Safe_uint32.(=) 
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 5 5 10#
     "expl:Pointer dereference"
     (acc  unsigned_intP_base_6_alloc_table
      !unsigned_intP_unsigned_intM_base_6 base ))
     (#"_parse_integer_fixup_radix.jc" 304 52 65# "expl:Integer cast"
     (Safe_uint32.of_int (0))) ))
    then
     (if
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 6 6 17#
     (Safe_int32.(=) 
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 6 6 10#
      "expl:Integer cast"
      (Safe_int32_of_Safe_int8.cast 
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 6 6 10#
       "expl:Pointer dereference"
       (acc  voidP_s_5_alloc_table charP_charM_s_5 !mutable_s_2 )) ))
      (#"_parse_integer_fixup_radix.jc" 306 21 34# "expl:Integer cast"
      (Safe_int32.of_int (48))) ))
     then
      begin
      (tmp :=
       (let _jessie_90 =
       (let _jessie_91 =
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 16 20#
       "expl:Pointer dereference"
       (acc_offset_typesafe  voidP_s_5_alloc_table charP_charM_s_5
        !mutable_s_2 (1) )) in
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 21#
       "expl:Precondition for _tolower"
       (Function__tolower_safe._tolower  _jessie_91 ))) in
       begin
       (assert {
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 21#
       "expl:Pointer index bounds" true) }); _jessie_90 end));
       (if
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 28#
       (Safe_int32.(=) 
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 21#
        "expl:Integer cast" (Safe_int32_of_Safe_int8.cast  !tmp ))
        (#"_parse_integer_fixup_radix.jc" 309 51 65# "expl:Integer cast"
        (Safe_int32.of_int (120))) ))
       then
        begin
        (tmp_0 :=
         (let _jessie_97 =
         (let _jessie_98 =
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 41 45#
         "expl:Pointer dereference"
         (acc_offset_typesafe  voidP_s_5_alloc_table charP_charM_s_5
          !mutable_s_2 (2) )) in
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 32 46#
         "expl:Precondition for isxdigit"
         (Function_isxdigit_0_safe.isxdigit_0  _jessie_98 ))) in
         begin
         (assert {
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 32 46#
         "expl:Pointer index bounds" true) }); _jessie_97 end));
         (if
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 32 46#
         (Safe_enum__bool.(<>)  !tmp_0
          (#"_parse_integer_fixup_radix.jc" 312 46 58# "expl:Integer cast"
          (Safe_enum__bool.of_int  (0) )) ))
         then
          (let _jessie_105 =
          (let _jessie_104 =
          (#"_parse_integer_fixup_radix.jc" 313 97 111# "expl:Integer cast"
          (Safe_uint32.of_int (16))) in
          begin
          (assert {
          (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 8 4 14#
          "expl:Pointer index bounds" true) }); _jessie_104 end) in
          (let _jessie_106 = base in
          (let _jessie_107 = (0) in
          (let _jessie_108 = _jessie_106 in
          (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 8 4 14#
          "expl:Pointer dereference"
          (upd  unsigned_intP_base_6_alloc_table
           unsigned_intP_unsigned_intM_base_6 _jessie_106 _jessie_105 ))))))
         else
          (let _jessie_100 =
          (let _jessie_99 =
          (#"_parse_integer_fixup_radix.jc" 314 53 66# "expl:Integer cast"
          (Safe_uint32.of_int (8))) in
          begin
          (assert {
          (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 10 4 13#
          "expl:Pointer index bounds" true) }); _jessie_99 end) in
          (let _jessie_101 = base in
          (let _jessie_102 = (0) in
          (let _jessie_103 = _jessie_101 in
          (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 10 4 13#
          "expl:Pointer dereference"
          (upd  unsigned_intP_base_6_alloc_table
           unsigned_intP_unsigned_intM_base_6 _jessie_101 _jessie_100 )))))))
        end
       else
        (let _jessie_93 =
        (let _jessie_92 =
        (#"_parse_integer_fixup_radix.jc" 315 57 70# "expl:Integer cast"
        (Safe_uint32.of_int (8))) in
        begin
        (assert {
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 10 4 13#
        "expl:Pointer index bounds" true) }); _jessie_92 end) in
        (let _jessie_94 = base in
        (let _jessie_95 = (0) in
        (let _jessie_96 = _jessie_94 in
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 10 4 13#
        "expl:Pointer dereference"
        (upd  unsigned_intP_base_6_alloc_table
         unsigned_intP_unsigned_intM_base_6 _jessie_94 _jessie_93 ))))))) end
     else
      (let _jessie_86 =
      (let _jessie_85 =
      (#"_parse_integer_fixup_radix.jc" 316 54 68# "expl:Integer cast"
      (Safe_uint32.of_int (10))) in
      begin
      (assert {
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 12 3 13#
      "expl:Pointer index bounds" true) }); _jessie_85 end) in
      (let _jessie_87 = base in
      (let _jessie_88 = (0) in
      (let _jessie_89 = _jessie_87 in
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 12 3 13#
      "expl:Pointer dereference"
      (upd  unsigned_intP_base_6_alloc_table
       unsigned_intP_unsigned_intM_base_6 _jessie_87 _jessie_86 )))))))
    else ());
     (if
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 5 16#
     (Safe_uint32.(=) 
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 5 10#
      "expl:Pointer dereference"
      (acc  unsigned_intP_base_6_alloc_table
       !unsigned_intP_unsigned_intM_base_6 base ))
      (#"_parse_integer_fixup_radix.jc" 317 52 66# "expl:Integer cast"
      (Safe_uint32.of_int (16))) ))
     then
      (if
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 20 31#
      (Safe_int32.(=) 
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 20 24#
       "expl:Integer cast"
       (Safe_int32_of_Safe_int8.cast 
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 20 24#
        "expl:Pointer dereference"
        (acc  voidP_s_5_alloc_table charP_charM_s_5 !mutable_s_2 )) ))
       (#"_parse_integer_fixup_radix.jc" 319 21 34# "expl:Integer cast"
       (Safe_int32.of_int (48))) ))
      then
       begin
       (tmp_1 :=
        (let _jessie_109 =
        (let _jessie_110 =
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 44 48#
        "expl:Pointer dereference"
        (acc_offset_typesafe  voidP_s_5_alloc_table charP_charM_s_5
         !mutable_s_2 (1) )) in
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 49#
        "expl:Precondition for _tolower"
        (Function__tolower_safe._tolower  _jessie_110 ))) in
        begin
        (assert {
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 49#
        "expl:Pointer index bounds" true) }); _jessie_109 end));
        (if
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 56#
        (Safe_int32.(=) 
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 49#
         "expl:Integer cast" (Safe_int32_of_Safe_int8.cast  !tmp_1 ))
         (#"_parse_integer_fixup_radix.jc" 322 53 67# "expl:Integer cast"
         (Safe_int32.of_int (120))) ))
        then
         (mutable_s_2 :=
          (let _jessie_111 =
          (shift_typesafe  !mutable_s_2
           (Safe_int32.to_int 
            (#"_parse_integer_fixup_radix.jc" 323 37 49# "expl:Integer cast"
            (Safe_int32.of_int (2))) ) ) in
          begin
          (assert {
          (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 15 2 8#
          "expl:Pointer index bounds" true) }); _jessie_111 end)) else ())
       end else ()) else ());
     begin
     (return :=
      (let _jessie_112 = !mutable_s_2 in
      begin
      (assert {
      (#"_parse_integer_fixup_radix.jc" 326 7 15# "expl:Pointer index bounds"
      true) }); _jessie_112 end)); (raise Return) end end))); absurd  end
    with Return -> !return end))
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Function__tolower

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val _tolower
  (c_1_0 : Int8.t) : Int8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 122 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (tolower (Int8.to_int c_1_0)))) }
  
end

module Function_isxdigit_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isxdigit_0
  (c_10 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 91 12 36#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isxdigit (Int8.to_int c_10)))) }
  
end

theory Axiomatic_IntBase

  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  predicate is_hex (s : (pointer voidP)) (charP_charM_s_2_at_L : (memory
  voidP Int8.t))
  =
     ((Int8.(=) (select charP_charM_s_2_at_L (shift s (0)))
      (#"_parse_integer_fixup_radix.jc" 253 26 38# "expl:Integer cast"
      (Int8.of_int (48))))
     /\
     (((=)
      (tolower (Int8.to_int (select charP_charM_s_2_at_L (shift s (1)))))
      (Int8.to_int (#"_parse_integer_fixup_radix.jc" 254 50 63#
      "expl:Integer cast" (Int8.of_int (120)))))
     /\ (isxdigit (Int8.to_int (select charP_charM_s_2_at_L (shift s (2)))))))
  
  
  predicate is_oct (s_0 : (pointer voidP)) (charP_charM_s_0_3_at_L : (memory
  voidP Int8.t))
  =
     ((Int8.(=) (select charP_charM_s_0_3_at_L (shift s_0 (0)))
      (#"_parse_integer_fixup_radix.jc" 258 27 39# "expl:Integer cast"
      (Int8.of_int (48))))
     /\ (not (is_hex s_0 charP_charM_s_0_3_at_L)))
  
  
  predicate is_dec (s_1 : (pointer voidP)) (charP_charM_s_1_4_at_L : (memory
  voidP Int8.t))
  =
     ((not (is_hex s_1 charP_charM_s_1_4_at_L)) /\
     (not (is_oct s_1 charP_charM_s_1_4_at_L)))
  
  
end

module Function__parse_integer_fixup_radix_behaviors
#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 3 11 73#
"expl:_parse_integer_fixup_radix, behaviors"

  use Unsafe_uint32 
  
  use Unsafe_int8 
  
  use Unsafe_int32_of_Unsafe_int8 
  
  use Unsafe_int32 
  
  use Unsafe_enum__bool 
  
  use enum.Uint32 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_isxdigit_0 
  
  use Function__tolower 
  
  use import Axiomatic_IntBase 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  let _parse_integer_fixup_radix_ensures_default
  #"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 3 11 73#
  "expl:Function _parse_integer_fixup_radix, default behavior" =
  fun
   (s_2 : (pointer voidP)) (base : (pointer unsigned_intP))
   (unsigned_intP_unsigned_intM_base_6 : ref (memory unsigned_intP Uint32.t))
   (unsigned_intP_base_6_alloc_table : (alloc_table unsigned_intP))
   (voidP_s_5_alloc_table : (alloc_table voidP)) (voidP_s_5_tag_table :
   (tag_table voidP)) (charP_charM_s_5 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_s_5_alloc_table s_2) ->
     (((=) (typeof voidP_s_5_tag_table s_2) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_5_alloc_table s_2) i) /\
       ((<) i (offset_max voidP_s_5_alloc_table s_2))) ->
       ((=) (typeof voidP_s_5_tag_table (shift s_2 i)) charP_tag)))))
   /\
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 13 13 29#
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409#
     ((<=) (offset_min voidP_s_5_alloc_table s_2) (0)))
    /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409#
     ((>=) (offset_max voidP_s_5_alloc_table s_2) (2)))
    /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)) /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)) /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)))))))))))
   /\
   (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 14 13 25#
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((<=) (offset_min unsigned_intP_base_6_alloc_table base) (0)))
   /\
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((>=) (offset_max unsigned_intP_base_6_alloc_table base) (0)))
   /\ (#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true))))))))))
   }
   ensures {
     ("expl:Postcondition"
     ((#"_parse_integer_fixup_radix.jc" 273 10 28# "expl:Assigns clause"
      (not_assigns unsigned_intP_base_6_alloc_table
      unsigned_intP_base_6_alloc_table (old
      !unsigned_intP_unsigned_intM_base_6)
      !unsigned_intP_unsigned_intM_base_6 (pset_singleton base)))
     /\
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 16 12 44#
     "expl:Ensures clause"
     (((=) result s_2) \/ ((=) result (shift s_2 (2))))))) }  ->
   (let mutable_s_2 = ref s_2 in
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (let tmp = ref (Unsafe_int8.any_  () ) in
    (let tmp_0 = ref (Unsafe_enum__bool.any_  () ) in
    (let tmp_1 = ref (Unsafe_int8.any_  () ) in
    begin
    (if
    (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 5 5 15#
    (Unsafe_uint32.(=)  (acc  !unsigned_intP_unsigned_intM_base_6 base )
     (#"_parse_integer_fixup_radix.jc" 304 52 65# "expl:Integer cast"
     (Unsafe_uint32.of_int (0))) ))
    then
     (if
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 6 6 17#
     (Unsafe_int32.(=) 
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 6 6 10#
      "expl:Integer cast"
      (Unsafe_int32_of_Unsafe_int8.cast 
       (acc  charP_charM_s_5
        (shift_  !mutable_s_2
         (Unsafe_int32.to_int 
          (#"_parse_integer_fixup_radix.jc" 305 53 65# "expl:Integer cast"
          (Unsafe_int32.of_int (0))) ) ) ) ))
      (#"_parse_integer_fixup_radix.jc" 306 21 34# "expl:Integer cast"
      (Unsafe_int32.of_int (48))) ))
     then
      begin
      (tmp :=
       (let _jessie_7 =
       (acc  charP_charM_s_5
        (shift_  !mutable_s_2
         (Unsafe_int32.to_int 
          (#"_parse_integer_fixup_radix.jc" 308 63 75# "expl:Integer cast"
          (Unsafe_int32.of_int (1))) ) ) ) in
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 21#
       "expl:Precondition for _tolower"
       (Function__tolower._tolower  _jessie_7 ))));
       (if
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 28#
       (Unsafe_int32.(=) 
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 21#
        "expl:Integer cast" (Unsafe_int32_of_Unsafe_int8.cast  !tmp ))
        (#"_parse_integer_fixup_radix.jc" 309 51 65# "expl:Integer cast"
        (Unsafe_int32.of_int (120))) ))
       then
        begin
        (tmp_0 :=
         (let _jessie_14 =
         (acc  charP_charM_s_5
          (shift_  !mutable_s_2
           (Unsafe_int32.to_int 
            (#"_parse_integer_fixup_radix.jc" 311 68 80# "expl:Integer cast"
            (Unsafe_int32.of_int (2))) ) ) ) in
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 32 46#
         "expl:Precondition for isxdigit"
         (Function_isxdigit_0.isxdigit_0  _jessie_14 ))));
         (if
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 32 46#
         (Unsafe_enum__bool.(<>)  !tmp_0
          (#"_parse_integer_fixup_radix.jc" 312 46 58# "expl:Integer cast"
          (Unsafe_enum__bool.of_int  (0) )) ))
         then
          (let _jessie_21 =
          (#"_parse_integer_fixup_radix.jc" 313 97 111# "expl:Integer cast"
          (Unsafe_uint32.of_int (16))) in
          (let _jessie_22 = base in
          (let _jessie_23 = (0) in
          (let _jessie_24 = _jessie_22 in
          (upd  unsigned_intP_unsigned_intM_base_6 _jessie_24 _jessie_21 )))))
         else
          (let _jessie_16 =
          (#"_parse_integer_fixup_radix.jc" 314 53 66# "expl:Integer cast"
          (Unsafe_uint32.of_int (8))) in
          (let _jessie_17 = base in
          (let _jessie_18 = (0) in
          (let _jessie_19 = _jessie_17 in
          (upd  unsigned_intP_unsigned_intM_base_6 _jessie_19 _jessie_16 ))))))
        end
       else
        (let _jessie_9 =
        (#"_parse_integer_fixup_radix.jc" 315 57 70# "expl:Integer cast"
        (Unsafe_uint32.of_int (8))) in
        (let _jessie_10 = base in
        (let _jessie_11 = (0) in
        (let _jessie_12 = _jessie_10 in
        (upd  unsigned_intP_unsigned_intM_base_6 _jessie_12 _jessie_9 ))))))
      end
     else
      (let _jessie_2 =
      (#"_parse_integer_fixup_radix.jc" 316 54 68# "expl:Integer cast"
      (Unsafe_uint32.of_int (10))) in
      (let _jessie_3 = base in
      (let _jessie_4 = (0) in
      (let _jessie_5 = _jessie_3 in
      (upd  unsigned_intP_unsigned_intM_base_6 _jessie_5 _jessie_2 ))))))
    else ());
     (if
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 5 16#
     (Unsafe_uint32.(=)  (acc  !unsigned_intP_unsigned_intM_base_6 base )
      (#"_parse_integer_fixup_radix.jc" 317 52 66# "expl:Integer cast"
      (Unsafe_uint32.of_int (16))) ))
     then
      (if
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 20 31#
      (Unsafe_int32.(=) 
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 20 24#
       "expl:Integer cast"
       (Unsafe_int32_of_Unsafe_int8.cast 
        (acc  charP_charM_s_5
         (shift_  !mutable_s_2
          (Unsafe_int32.to_int 
           (#"_parse_integer_fixup_radix.jc" 318 53 65# "expl:Integer cast"
           (Unsafe_int32.of_int (0))) ) ) ) ))
       (#"_parse_integer_fixup_radix.jc" 319 21 34# "expl:Integer cast"
       (Unsafe_int32.of_int (48))) ))
      then
       begin
       (tmp_1 :=
        (let _jessie_26 =
        (acc  charP_charM_s_5
         (shift_  !mutable_s_2
          (Unsafe_int32.to_int 
           (#"_parse_integer_fixup_radix.jc" 321 65 77# "expl:Integer cast"
           (Unsafe_int32.of_int (1))) ) ) ) in
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 49#
        "expl:Precondition for _tolower"
        (Function__tolower._tolower  _jessie_26 ))));
        (if
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 56#
        (Unsafe_int32.(=) 
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 49#
         "expl:Integer cast" (Unsafe_int32_of_Unsafe_int8.cast  !tmp_1 ))
         (#"_parse_integer_fixup_radix.jc" 322 53 67# "expl:Integer cast"
         (Unsafe_int32.of_int (120))) ))
        then
         (mutable_s_2 :=
          (shift_  !mutable_s_2
           (Unsafe_int32.to_int 
            (#"_parse_integer_fixup_radix.jc" 323 37 49# "expl:Integer cast"
            (Unsafe_int32.of_int (2))) ) )) else ()) end else ()) else ());
     begin (return := !mutable_s_2); (raise Return) end end))); absurd  end
    with Return -> !return end))
  
  let _parse_integer_fixup_radix_ensures_guess
  #"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 3 11 73#
  "expl:Function _parse_integer_fixup_radix, behavior guess" =
  fun
   (s_2 : (pointer voidP)) (base : (pointer unsigned_intP))
   (unsigned_intP_unsigned_intM_base_6 : ref (memory unsigned_intP Uint32.t))
   (unsigned_intP_base_6_alloc_table : (alloc_table unsigned_intP))
   (voidP_s_5_alloc_table : (alloc_table voidP)) (voidP_s_5_tag_table :
   (tag_table voidP)) (charP_charM_s_5 : (memory voidP Int8.t)) 
   requires {
   ((Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
    (#"_parse_integer_fixup_radix.jc" 276 33 46# "expl:Integer cast"
    (Uint32.of_int (0))))
   /\
   (((allocated voidP_s_5_alloc_table s_2) ->
     (((=) (typeof voidP_s_5_tag_table s_2) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_5_alloc_table s_2) i) /\
       ((<) i (offset_max voidP_s_5_alloc_table s_2))) ->
       ((=) (typeof voidP_s_5_tag_table (shift s_2 i)) charP_tag)))))
   /\
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 13 13 29#
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409#
     ((<=) (offset_min voidP_s_5_alloc_table s_2) (0)))
    /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409#
     ((>=) (offset_max voidP_s_5_alloc_table s_2) (2)))
    /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)) /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)) /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)))))))))))
   /\
   (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 14 13 25#
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((<=) (offset_min unsigned_intP_base_6_alloc_table base) (0)))
   /\
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((>=) (offset_max unsigned_intP_base_6_alloc_table base) (0)))
   /\ (#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)))))))))))
   }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
     "expl:Ensures clause"
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
      "expl:Ensures clause"
      ((is_hex s_2 charP_charM_s_5) ->
       (Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
       (#"_parse_integer_fixup_radix.jc" 279 33 47# "expl:Integer cast"
       (Uint32.of_int (16))))))
     /\
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 20 15 39#
      "expl:Ensures clause"
      ((is_oct s_2 charP_charM_s_5) ->
       (Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
       (#"_parse_integer_fixup_radix.jc" 282 35 48# "expl:Integer cast"
       (Uint32.of_int (8))))))
     /\
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 21 15 40#
      "expl:Ensures clause"
      ((is_dec s_2 charP_charM_s_5) ->
       (Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
       (#"_parse_integer_fixup_radix.jc" 285 37 51# "expl:Integer cast"
       (Uint32.of_int (10))))))
     /\
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 22 15 45#
      "expl:Ensures clause"
      ((is_hex s_2 charP_charM_s_5) -> ((=) result (shift s_2 (2)))))
     /\
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 23 15 54#
     "expl:Ensures clause"
     (((is_oct s_2 charP_charM_s_5) \/ (is_dec s_2 charP_charM_s_5)) ->
      ((=) result s_2))))))))))))) }  ->
   (let mutable_s_2 = ref s_2 in
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (let tmp = ref (Unsafe_int8.any_  () ) in
    (let tmp_0 = ref (Unsafe_enum__bool.any_  () ) in
    (let tmp_1 = ref (Unsafe_int8.any_  () ) in
    begin
    (if
    (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 5 5 15#
    (Unsafe_uint32.(=)  (acc  !unsigned_intP_unsigned_intM_base_6 base )
     (#"_parse_integer_fixup_radix.jc" 304 52 65# "expl:Integer cast"
     (Unsafe_uint32.of_int (0))) ))
    then
     (if
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 6 6 17#
     (Unsafe_int32.(=) 
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 6 6 10#
      "expl:Integer cast"
      (Unsafe_int32_of_Unsafe_int8.cast 
       (acc  charP_charM_s_5
        (shift_  !mutable_s_2
         (Unsafe_int32.to_int 
          (#"_parse_integer_fixup_radix.jc" 305 53 65# "expl:Integer cast"
          (Unsafe_int32.of_int (0))) ) ) ) ))
      (#"_parse_integer_fixup_radix.jc" 306 21 34# "expl:Integer cast"
      (Unsafe_int32.of_int (48))) ))
     then
      begin
      (tmp :=
       (let _jessie_35 =
       (acc  charP_charM_s_5
        (shift_  !mutable_s_2
         (Unsafe_int32.to_int 
          (#"_parse_integer_fixup_radix.jc" 308 63 75# "expl:Integer cast"
          (Unsafe_int32.of_int (1))) ) ) ) in
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 21#
       "expl:Precondition for _tolower"
       (Function__tolower._tolower  _jessie_35 ))));
       (if
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 28#
       (Unsafe_int32.(=) 
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 21#
        "expl:Integer cast" (Unsafe_int32_of_Unsafe_int8.cast  !tmp ))
        (#"_parse_integer_fixup_radix.jc" 309 51 65# "expl:Integer cast"
        (Unsafe_int32.of_int (120))) ))
       then
        begin
        (tmp_0 :=
         (let _jessie_42 =
         (acc  charP_charM_s_5
          (shift_  !mutable_s_2
           (Unsafe_int32.to_int 
            (#"_parse_integer_fixup_radix.jc" 311 68 80# "expl:Integer cast"
            (Unsafe_int32.of_int (2))) ) ) ) in
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 32 46#
         "expl:Precondition for isxdigit"
         (Function_isxdigit_0.isxdigit_0  _jessie_42 ))));
         (if
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 32 46#
         (Unsafe_enum__bool.(<>)  !tmp_0
          (#"_parse_integer_fixup_radix.jc" 312 46 58# "expl:Integer cast"
          (Unsafe_enum__bool.of_int  (0) )) ))
         then
          (let _jessie_49 =
          (#"_parse_integer_fixup_radix.jc" 313 97 111# "expl:Integer cast"
          (Unsafe_uint32.of_int (16))) in
          (let _jessie_50 = base in
          (let _jessie_51 = (0) in
          (let _jessie_52 = _jessie_50 in
          (upd  unsigned_intP_unsigned_intM_base_6 _jessie_52 _jessie_49 )))))
         else
          (let _jessie_44 =
          (#"_parse_integer_fixup_radix.jc" 314 53 66# "expl:Integer cast"
          (Unsafe_uint32.of_int (8))) in
          (let _jessie_45 = base in
          (let _jessie_46 = (0) in
          (let _jessie_47 = _jessie_45 in
          (upd  unsigned_intP_unsigned_intM_base_6 _jessie_47 _jessie_44 ))))))
        end
       else
        (let _jessie_37 =
        (#"_parse_integer_fixup_radix.jc" 315 57 70# "expl:Integer cast"
        (Unsafe_uint32.of_int (8))) in
        (let _jessie_38 = base in
        (let _jessie_39 = (0) in
        (let _jessie_40 = _jessie_38 in
        (upd  unsigned_intP_unsigned_intM_base_6 _jessie_40 _jessie_37 ))))))
      end
     else
      (let _jessie_30 =
      (#"_parse_integer_fixup_radix.jc" 316 54 68# "expl:Integer cast"
      (Unsafe_uint32.of_int (10))) in
      (let _jessie_31 = base in
      (let _jessie_32 = (0) in
      (let _jessie_33 = _jessie_31 in
      (upd  unsigned_intP_unsigned_intM_base_6 _jessie_33 _jessie_30 ))))))
    else ());
     (if
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 5 16#
     (Unsafe_uint32.(=)  (acc  !unsigned_intP_unsigned_intM_base_6 base )
      (#"_parse_integer_fixup_radix.jc" 317 52 66# "expl:Integer cast"
      (Unsafe_uint32.of_int (16))) ))
     then
      (if
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 20 31#
      (Unsafe_int32.(=) 
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 20 24#
       "expl:Integer cast"
       (Unsafe_int32_of_Unsafe_int8.cast 
        (acc  charP_charM_s_5
         (shift_  !mutable_s_2
          (Unsafe_int32.to_int 
           (#"_parse_integer_fixup_radix.jc" 318 53 65# "expl:Integer cast"
           (Unsafe_int32.of_int (0))) ) ) ) ))
       (#"_parse_integer_fixup_radix.jc" 319 21 34# "expl:Integer cast"
       (Unsafe_int32.of_int (48))) ))
      then
       begin
       (tmp_1 :=
        (let _jessie_54 =
        (acc  charP_charM_s_5
         (shift_  !mutable_s_2
          (Unsafe_int32.to_int 
           (#"_parse_integer_fixup_radix.jc" 321 65 77# "expl:Integer cast"
           (Unsafe_int32.of_int (1))) ) ) ) in
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 49#
        "expl:Precondition for _tolower"
        (Function__tolower._tolower  _jessie_54 ))));
        (if
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 56#
        (Unsafe_int32.(=) 
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 49#
         "expl:Integer cast" (Unsafe_int32_of_Unsafe_int8.cast  !tmp_1 ))
         (#"_parse_integer_fixup_radix.jc" 322 53 67# "expl:Integer cast"
         (Unsafe_int32.of_int (120))) ))
        then
         (mutable_s_2 :=
          (shift_  !mutable_s_2
           (Unsafe_int32.to_int 
            (#"_parse_integer_fixup_radix.jc" 323 37 49# "expl:Integer cast"
            (Unsafe_int32.of_int (2))) ) )) else ()) end else ()) else ());
     begin (return := !mutable_s_2); (raise Return) end end))); absurd  end
    with Return -> !return end))
  
  let _parse_integer_fixup_radix_ensures_shift
  #"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 3 11 73#
  "expl:Function _parse_integer_fixup_radix, behavior shift" =
  fun
   (s_2 : (pointer voidP)) (base : (pointer unsigned_intP))
   (unsigned_intP_unsigned_intM_base_6 : ref (memory unsigned_intP Uint32.t))
   (unsigned_intP_base_6_alloc_table : (alloc_table unsigned_intP))
   (voidP_s_5_alloc_table : (alloc_table voidP)) (voidP_s_5_tag_table :
   (tag_table voidP)) (charP_charM_s_5 : (memory voidP Int8.t)) 
   requires {
   (((Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
     (#"_parse_integer_fixup_radix.jc" 292 35 49# "expl:Integer cast"
     (Uint32.of_int (16))))
    /\
    ((Int8.(=) (select charP_charM_s_5 (shift s_2 (0)))
     (#"_parse_integer_fixup_radix.jc" 293 31 43# "expl:Integer cast"
     (Int8.of_int (48))))
    /\
    ((=) (tolower (Int8.to_int (select charP_charM_s_5 (shift s_2 (1)))))
    (Int8.to_int (#"_parse_integer_fixup_radix.jc" 295 15 28#
    "expl:Integer cast" (Int8.of_int (120)))))))
   /\
   (((allocated voidP_s_5_alloc_table s_2) ->
     (((=) (typeof voidP_s_5_tag_table s_2) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_5_alloc_table s_2) i) /\
       ((<) i (offset_max voidP_s_5_alloc_table s_2))) ->
       ((=) (typeof voidP_s_5_tag_table (shift s_2 i)) charP_tag)))))
   /\
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 13 13 29#
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409#
     ((<=) (offset_min voidP_s_5_alloc_table s_2) (0)))
    /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409#
     ((>=) (offset_max voidP_s_5_alloc_table s_2) (2)))
    /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)) /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)) /\
    (#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)))))))))))
   /\
   (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 14 13 25#
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((<=) (offset_min unsigned_intP_base_6_alloc_table base) (0)))
   /\
   (#"_parse_integer_fixup_radix.jc" 266 12 409#
   ((#"_parse_integer_fixup_radix.jc" 266 12 409#
    ((>=) (offset_max unsigned_intP_base_6_alloc_table base) (0)))
   /\ (#"_parse_integer_fixup_radix.jc" 266 12 409# ((=) true true)))))))))))
   }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 26 15 37#
     "expl:Ensures clause" ((=) result (shift s_2 (2))))) }  ->
   (let mutable_s_2 = ref s_2 in
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (let tmp = ref (Unsafe_int8.any_  () ) in
    (let tmp_0 = ref (Unsafe_enum__bool.any_  () ) in
    (let tmp_1 = ref (Unsafe_int8.any_  () ) in
    begin
    (if
    (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 5 5 15#
    (Unsafe_uint32.(=)  (acc  !unsigned_intP_unsigned_intM_base_6 base )
     (#"_parse_integer_fixup_radix.jc" 304 52 65# "expl:Integer cast"
     (Unsafe_uint32.of_int (0))) ))
    then
     (if
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 6 6 17#
     (Unsafe_int32.(=) 
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 6 6 10#
      "expl:Integer cast"
      (Unsafe_int32_of_Unsafe_int8.cast 
       (acc  charP_charM_s_5
        (shift_  !mutable_s_2
         (Unsafe_int32.to_int 
          (#"_parse_integer_fixup_radix.jc" 305 53 65# "expl:Integer cast"
          (Unsafe_int32.of_int (0))) ) ) ) ))
      (#"_parse_integer_fixup_radix.jc" 306 21 34# "expl:Integer cast"
      (Unsafe_int32.of_int (48))) ))
     then
      begin
      (tmp :=
       (let _jessie_63 =
       (acc  charP_charM_s_5
        (shift_  !mutable_s_2
         (Unsafe_int32.to_int 
          (#"_parse_integer_fixup_radix.jc" 308 63 75# "expl:Integer cast"
          (Unsafe_int32.of_int (1))) ) ) ) in
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 21#
       "expl:Precondition for _tolower"
       (Function__tolower._tolower  _jessie_63 ))));
       (if
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 28#
       (Unsafe_int32.(=) 
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 7 21#
        "expl:Integer cast" (Unsafe_int32_of_Unsafe_int8.cast  !tmp ))
        (#"_parse_integer_fixup_radix.jc" 309 51 65# "expl:Integer cast"
        (Unsafe_int32.of_int (120))) ))
       then
        begin
        (tmp_0 :=
         (let _jessie_70 =
         (acc  charP_charM_s_5
          (shift_  !mutable_s_2
           (Unsafe_int32.to_int 
            (#"_parse_integer_fixup_radix.jc" 311 68 80# "expl:Integer cast"
            (Unsafe_int32.of_int (2))) ) ) ) in
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 32 46#
         "expl:Precondition for isxdigit"
         (Function_isxdigit_0.isxdigit_0  _jessie_70 ))));
         (if
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 7 32 46#
         (Unsafe_enum__bool.(<>)  !tmp_0
          (#"_parse_integer_fixup_radix.jc" 312 46 58# "expl:Integer cast"
          (Unsafe_enum__bool.of_int  (0) )) ))
         then
          (let _jessie_77 =
          (#"_parse_integer_fixup_radix.jc" 313 97 111# "expl:Integer cast"
          (Unsafe_uint32.of_int (16))) in
          (let _jessie_78 = base in
          (let _jessie_79 = (0) in
          (let _jessie_80 = _jessie_78 in
          (upd  unsigned_intP_unsigned_intM_base_6 _jessie_80 _jessie_77 )))))
         else
          (let _jessie_72 =
          (#"_parse_integer_fixup_radix.jc" 314 53 66# "expl:Integer cast"
          (Unsafe_uint32.of_int (8))) in
          (let _jessie_73 = base in
          (let _jessie_74 = (0) in
          (let _jessie_75 = _jessie_73 in
          (upd  unsigned_intP_unsigned_intM_base_6 _jessie_75 _jessie_72 ))))))
        end
       else
        (let _jessie_65 =
        (#"_parse_integer_fixup_radix.jc" 315 57 70# "expl:Integer cast"
        (Unsafe_uint32.of_int (8))) in
        (let _jessie_66 = base in
        (let _jessie_67 = (0) in
        (let _jessie_68 = _jessie_66 in
        (upd  unsigned_intP_unsigned_intM_base_6 _jessie_68 _jessie_65 ))))))
      end
     else
      (let _jessie_58 =
      (#"_parse_integer_fixup_radix.jc" 316 54 68# "expl:Integer cast"
      (Unsafe_uint32.of_int (10))) in
      (let _jessie_59 = base in
      (let _jessie_60 = (0) in
      (let _jessie_61 = _jessie_59 in
      (upd  unsigned_intP_unsigned_intM_base_6 _jessie_61 _jessie_58 ))))))
    else ());
     (if
     (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 5 16#
     (Unsafe_uint32.(=)  (acc  !unsigned_intP_unsigned_intM_base_6 base )
      (#"_parse_integer_fixup_radix.jc" 317 52 66# "expl:Integer cast"
      (Unsafe_uint32.of_int (16))) ))
     then
      (if
      (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 20 31#
      (Unsafe_int32.(=) 
       (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 20 24#
       "expl:Integer cast"
       (Unsafe_int32_of_Unsafe_int8.cast 
        (acc  charP_charM_s_5
         (shift_  !mutable_s_2
          (Unsafe_int32.to_int 
           (#"_parse_integer_fixup_radix.jc" 318 53 65# "expl:Integer cast"
           (Unsafe_int32.of_int (0))) ) ) ) ))
       (#"_parse_integer_fixup_radix.jc" 319 21 34# "expl:Integer cast"
       (Unsafe_int32.of_int (48))) ))
      then
       begin
       (tmp_1 :=
        (let _jessie_82 =
        (acc  charP_charM_s_5
         (shift_  !mutable_s_2
          (Unsafe_int32.to_int 
           (#"_parse_integer_fixup_radix.jc" 321 65 77# "expl:Integer cast"
           (Unsafe_int32.of_int (1))) ) ) ) in
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 49#
        "expl:Precondition for _tolower"
        (Function__tolower._tolower  _jessie_82 ))));
        (if
        (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 56#
        (Unsafe_int32.(=) 
         (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.c" 14 35 49#
         "expl:Integer cast" (Unsafe_int32_of_Unsafe_int8.cast  !tmp_1 ))
         (#"_parse_integer_fixup_radix.jc" 322 53 67# "expl:Integer cast"
         (Unsafe_int32.of_int (120))) ))
        then
         (mutable_s_2 :=
          (shift_  !mutable_s_2
           (Unsafe_int32.to_int 
            (#"_parse_integer_fixup_radix.jc" 323 37 49# "expl:Integer cast"
            (Unsafe_int32.of_int (2))) ) )) else ()) end else ()) else ());
     begin (return := !mutable_s_2); (raise Return) end end))); absurd  end
    with Return -> !return end))
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

theory Struct_unsigned_intP

  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function unsigned_intP_tag  : (tag_id
  unsigned_intP)
  
  axiom Unsigned_intP_parenttag_bottom :
  (parenttag unsigned_intP_tag bottom_tag)
  
  axiom Unsigned_intP_is_final :
  (forall unsigned_intP_tag_table : (tag_table unsigned_intP).
   (forall p : (pointer unsigned_intP).
    ((instanceof unsigned_intP_tag_table p unsigned_intP_tag) ->
     ((=) (typeof unsigned_intP_tag_table p) unsigned_intP_tag))))
  
  predicate frame_tag_struct_unsigned_intP (p : (pointer unsigned_intP))
  (old_unsigned_intP_tag_table : (tag_table unsigned_intP))
  (unsigned_intP_tag_table : (tag_table unsigned_intP))
  =
     ((tag_extends old_unsigned_intP_tag_table unsigned_intP_tag_table) /\
     (alloc_tag_block old_unsigned_intP_tag_table unsigned_intP_tag_table p))
  
  predicate frame_free_struct_unsigned_intP (p : (pointer unsigned_intP))
  (old_unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  =
     ((free_extends old_unsigned_intP_alloc_table unsigned_intP_alloc_table)
     /\
     (free_block old_unsigned_intP_alloc_table unsigned_intP_alloc_table p))
  
  predicate frame_alloc_struct_unsigned_intP (p : (pointer unsigned_intP)) (n
  : int) (old_unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  =
     ((alloc_extends old_unsigned_intP_alloc_table unsigned_intP_alloc_table)
     /\
     (alloc_block old_unsigned_intP_alloc_table unsigned_intP_alloc_table p
     n))
  
  predicate fresh_tag_struct_unsigned_intP (p : (pointer unsigned_intP))
  (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = (tag_fresh unsigned_intP_tag_table p)
  
  predicate fresh_alloc_struct_unsigned_intP (p : (pointer unsigned_intP))
  (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  = (alloc_fresh unsigned_intP_alloc_table p)
  
  predicate container_of_singleton_struct_unsigned_intP (p : (pointer
  unsigned_intP)) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = true
  
  predicate container_of_struct_unsigned_intP (p : (pointer unsigned_intP))
  (l : int) (r : int) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = true
  
  predicate typeof_singleton_struct_unsigned_intP (p : (pointer
  unsigned_intP)) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = ((=) (typeof unsigned_intP_tag_table p) unsigned_intP_tag)
  
  predicate typeof_struct_unsigned_intP (p : (pointer unsigned_intP)) (l :
  int) (r : int) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  =
     (((=) (typeof unsigned_intP_tag_table p) unsigned_intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof unsigned_intP_tag_table (shift p i)) unsigned_intP_tag))))
  
  predicate instanceof_singleton_struct_unsigned_intP (p : (pointer
  unsigned_intP)) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  = (instanceof unsigned_intP_tag_table p unsigned_intP_tag)
  
  predicate instanceof_struct_unsigned_intP (p : (pointer unsigned_intP)) (l
  : int) (r : int) (unsigned_intP_tag_table : (tag_table unsigned_intP))
  =
     ((instanceof unsigned_intP_tag_table p unsigned_intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof unsigned_intP_tag_table (shift p i) unsigned_intP_tag))))
  
  predicate right_valid_struct_unsigned_intP (p : (pointer unsigned_intP)) (b
  : int) (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  = ((>=) (offset_max unsigned_intP_alloc_table p) b)
  
  predicate left_valid_struct_unsigned_intP (p : (pointer unsigned_intP)) (a
  : int) (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  = ((<=) (offset_min unsigned_intP_alloc_table p) a)
  
  predicate valid_struct_unsigned_intP (p : (pointer unsigned_intP)) (a :
  int) (b : int) (unsigned_intP_alloc_table : (alloc_table unsigned_intP))
  =
     (((<=) (offset_min unsigned_intP_alloc_table p) a) /\
     ((>=) (offset_max unsigned_intP_alloc_table p) b))
  
  predicate strict_valid_struct_unsigned_intP (p : (pointer unsigned_intP))
  (a : int) (b : int) (unsigned_intP_alloc_table : (alloc_table
  unsigned_intP))
  =
     (((=) (offset_min unsigned_intP_alloc_table p) a) /\
     ((=) (offset_max unsigned_intP_alloc_table p) b))
  
  axiom Unsigned_intP_int : ((=) (int_of_tag unsigned_intP_tag) (4))
  
end

module Struct_unsigned_intP_unsafe

  use import Struct_unsigned_intP 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_unsigned_intP
  (p : (pointer unsigned_intP)) 
   (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !unsigned_intP_alloc_table p)) }
    writes { unsigned_intP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_intP_alloc_table (old !unsigned_intP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_intP p (old !unsigned_intP_alloc_table)
       !unsigned_intP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_intP p !unsigned_intP_alloc_table))) }
  
  val allocate_struct_unsigned_intP_requires
  (n : int) 
   (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) 
    (unsigned_intP_tag_table : ref (tag_table unsigned_intP)) : (pointer
     unsigned_intP)
     requires { ((>=) n (0)) } writes { unsigned_intP_alloc_table,
     unsigned_intP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_intP result (0) (Int.(-) n (1))
        !unsigned_intP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_intP result n (old
        !unsigned_intP_alloc_table) !unsigned_intP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_intP result (old !unsigned_intP_tag_table)
        !unsigned_intP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_intP result (old
        !unsigned_intP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_intP result (old
        !unsigned_intP_tag_table))
       /\
       ((typeof_struct_unsigned_intP result (0) n !unsigned_intP_tag_table)
       /\
       (container_of_struct_unsigned_intP result (0) n
       !unsigned_intP_tag_table))))))) }
  
end

module Struct_unsigned_intP_safe

  use import Struct_unsigned_intP 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_unsigned_intP
  (p : (pointer unsigned_intP)) 
   (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) : unit
    requires { true } writes { unsigned_intP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_intP_alloc_table (old !unsigned_intP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_intP p (old !unsigned_intP_alloc_table)
       !unsigned_intP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_intP p !unsigned_intP_alloc_table))) }
  
  val allocate_struct_unsigned_intP
  (n : int) 
   (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) 
    (unsigned_intP_tag_table : ref (tag_table unsigned_intP)) : (pointer
     unsigned_intP)
     requires { true } writes { unsigned_intP_alloc_table,
     unsigned_intP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_intP result (0) (Int.(-) n (1))
        !unsigned_intP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_intP result n (old
        !unsigned_intP_alloc_table) !unsigned_intP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_intP result (old !unsigned_intP_tag_table)
        !unsigned_intP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_intP result (old
        !unsigned_intP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_intP result (old
        !unsigned_intP_tag_table))
       /\
       ((typeof_struct_unsigned_intP result (0) n !unsigned_intP_tag_table)
       /\
       (container_of_struct_unsigned_intP result (0) n
       !unsigned_intP_tag_table))))))) }
  
  val allocate_singleton_struct_unsigned_intP
  (unsigned_intP_alloc_table : ref (alloc_table unsigned_intP)) 
   (unsigned_intP_tag_table : ref (tag_table unsigned_intP)) : (pointer
    unsigned_intP)
    requires { true } writes { unsigned_intP_alloc_table,
    unsigned_intP_tag_table }
    ensures {
      ((strict_valid_struct_unsigned_intP result (0) (0)
       !unsigned_intP_alloc_table)
      /\
      ((frame_alloc_struct_unsigned_intP result (1) (old
       !unsigned_intP_alloc_table) !unsigned_intP_alloc_table)
      /\
      ((frame_tag_struct_unsigned_intP result (old !unsigned_intP_tag_table)
       !unsigned_intP_tag_table)
      /\
      ((fresh_alloc_struct_unsigned_intP result (old
       !unsigned_intP_alloc_table))
      /\
      ((fresh_tag_struct_unsigned_intP result (old !unsigned_intP_tag_table))
      /\
      ((typeof_singleton_struct_unsigned_intP result
       !unsigned_intP_tag_table)
      /\
      (container_of_singleton_struct_unsigned_intP result
      !unsigned_intP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_uint8

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_uint8

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Uint8.to_int n)) }
  
end

theory Enum__bool_of_Uint8

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Enum__bool.t
  = (Enum__bool.of_int (Uint8.to_int n))
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_uint64

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_uint64

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Uint64.to_int n)) }
  
end

theory Enum__bool_of_Uint64

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Enum__bool.t
  = (Enum__bool.of_int (Uint64.to_int n))
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_uint32

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_uint32

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Uint32.to_int n)) }
  
end

theory Enum__bool_of_Uint32

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Enum__bool.t
  = (Enum__bool.of_int (Uint32.to_int n))
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_uint16

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_uint16

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Uint16.to_int n)) }
  
end

theory Enum__bool_of_Uint16

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Enum__bool.t
  = (Enum__bool.of_int (Uint16.to_int n))
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_int8

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_int8

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Int8.to_int n)) }
  
end

theory Enum__bool_of_Int8

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Enum__bool.t
  = (Enum__bool.of_int (Int8.to_int n))
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_int64

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_int64

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Int64.to_int n)) }
  
end

theory Enum__bool_of_Int64

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Enum__bool.t
  = (Enum__bool.of_int (Int64.to_int n))
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_int32

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_int32

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Int32.to_int n)) }
  
end

theory Enum__bool_of_Int32

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Enum__bool.t
  = (Enum__bool.of_int (Int32.to_int n))
  
end

module Safe_enum__bool_of_Safe_int16

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_int16

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Int16.to_int n)) }
  
end

theory Enum__bool_of_Int16

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Enum__bool.t
  = (Enum__bool.of_int (Int16.to_int n))
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_uint8_of_Safe_enum__bool

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_enum__bool

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Enum__bool.to_int n)) }
  
end

theory Uint8_of_Enum__bool

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Uint8.t
  = (Uint8.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_uint64_of_Safe_enum__bool

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_enum__bool

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Enum__bool.to_int n)) }
  
end

theory Uint64_of_Enum__bool

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Uint64.t
  = (Uint64.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_uint32_of_Safe_enum__bool

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_enum__bool

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Enum__bool.to_int n)) }
  
end

theory Uint32_of_Enum__bool

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Uint32.t
  = (Uint32.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_uint16_of_Safe_enum__bool

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_enum__bool

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Enum__bool.to_int n)) }
  
end

theory Uint16_of_Enum__bool

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Uint16.t
  = (Uint16.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_int8_of_Safe_enum__bool

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int8.t
   requires { true }
   ensures { ((=) (Int8.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_enum__bool

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int8.t
   requires { true }
   ensures { ((=) (Int8.to_int result) (Enum__bool.to_int n)) }
  
end

theory Int8_of_Enum__bool

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Int8.t
  = (Int8.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_int64_of_Safe_enum__bool

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_enum__bool

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Enum__bool.to_int n)) }
  
end

theory Int64_of_Enum__bool

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Int64.t
  = (Int64.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Safe_int32_of_Safe_enum__bool

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_enum__bool

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Enum__bool.to_int n)) }
  
end

theory Int32_of_Enum__bool

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Int32.t
  = (Int32.of_int (Enum__bool.to_int n))
  
end

module Safe_int16_of_Safe_enum__bool

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_enum__bool

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Enum__bool.to_int n)) }
  
end

theory Int16_of_Enum__bool

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Int16.t
  = (Int16.of_int (Enum__bool.to_int n))
  
end

module Function_isalnum_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isalnum_0
  (c_2_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 77 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isalnum (Int8.to_int c_2_0)))) }
  
end

module Function_isalnum_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isalnum_0
  (c_2_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 77 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isalnum (Int8.to_int c_2_0)))) }
  
end

module Function_isalpha_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isalpha_0
  (c_3_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 79 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isalpha (Int8.to_int c_3_0)))) }
  
end

module Function_isalpha_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isalpha_0
  (c_3_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 79 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isalpha (Int8.to_int c_3_0)))) }
  
end

module Function_islower_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val islower_0
  (c_6_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 83 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (islower (Int8.to_int c_6_0)))) }
  
end

module Function_islower_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val islower_0
  (c_6_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 83 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (islower (Int8.to_int c_6_0)))) }
  
end

module Function_isspace_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isspace_0
  (c_8_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 87 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isspace (Int8.to_int c_8_0)))) }
  
end

module Function_isspace_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isspace_0
  (c_8_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 87 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isspace (Int8.to_int c_8_0)))) }
  
end

module Function_isupper_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isupper_0
  (c_9 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 89 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <-> (isupper (Int8.to_int c_9))))
     }
  
end

module Function_isupper_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isupper_0
  (c_9 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 89 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <-> (isupper (Int8.to_int c_9))))
     }
  
end

module Function_isascii

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val isascii
  (c_4_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 94 12 40#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     ((Int8.(<=) (#"_parse_integer_fixup_radix.jc" 200 23 34#
      "expl:Integer cast" (Int8.of_int (0))) c_4_0)
     /\
     (Int8.(<=) c_4_0 (#"_parse_integer_fixup_radix.jc" 201 40 53#
     "expl:Integer cast" (Int8.of_int (127))))))) }
  
end

module Function_isascii_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val isascii
  (c_4_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 94 12 40#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     ((Int8.(<=) (#"_parse_integer_fixup_radix.jc" 200 23 34#
      "expl:Integer cast" (Int8.of_int (0))) c_4_0)
     /\
     (Int8.(<=) c_4_0 (#"_parse_integer_fixup_radix.jc" 201 40 53#
     "expl:Integer cast" (Int8.of_int (127))))))) }
  
end

module Function_isdigit_0

  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isdigit_0
  (c_5_0 : Int32.t) : Int32.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 99 12 35#
     "expl:Ensures clause"
     (((<>) (Int32.to_int result) (0)) <-> (isdigit (Int32.to_int c_5_0)))) }
  
end

module Function_isdigit_0_safe

  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isdigit_0
  (c_5_0 : Int32.t) : Int32.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 99 12 35#
     "expl:Ensures clause"
     (((<>) (Int32.to_int result) (0)) <-> (isdigit (Int32.to_int c_5_0)))) }
  
end

module Function___tolower

  use enum.Uint8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val __tolower
  (c_11 : Uint8.t) : Uint8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 102 12 33#
     "expl:Ensures clause"
     ((=) (Uint8.to_int result) (tolower (Uint8.to_int c_11)))) }
  
end

module Function___tolower_safe

  use enum.Uint8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val __tolower
  (c_11 : Uint8.t) : Uint8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 102 12 33#
     "expl:Ensures clause"
     ((=) (Uint8.to_int result) (tolower (Uint8.to_int c_11)))) }
  
end

module Function___toupper

  use enum.Uint8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val __toupper
  (c_0_0 : Uint8.t) : Uint8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 105 12 33#
     "expl:Ensures clause"
     ((=) (Uint8.to_int result) (toupper (Uint8.to_int c_0_0)))) }
  
end

module Function___toupper_safe

  use enum.Uint8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val __toupper
  (c_0_0 : Uint8.t) : Uint8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 105 12 33#
     "expl:Ensures clause"
     ((=) (Uint8.to_int result) (toupper (Uint8.to_int c_0_0)))) }
  
end

module Function_tolower_0

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val tolower_0
  (c_11_0 : Int8.t) : Int8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 112 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (tolower (Int8.to_int c_11_0)))) }
  
end

module Function_tolower_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val tolower_0
  (c_11_0 : Int8.t) : Int8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 112 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (tolower (Int8.to_int c_11_0)))) }
  
end

module Function_toupper_0

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val toupper_0
  (c_12 : Int8.t) : Int8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 114 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (toupper (Int8.to_int c_12)))) }
  
end

module Function_toupper_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val toupper_0
  (c_12 : Int8.t) : Int8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 114 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (toupper (Int8.to_int c_12)))) }
  
end

module Function_isodigit_0

  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isodigit_0
  (c_7_0 : Int8.t) : Int32.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 126 12 36#
     "expl:Ensures clause"
     (((<>) (Int32.to_int result) (0)) <-> (isodigit (Int8.to_int c_7_0)))) }
  
end

module Function_isodigit_0_safe

  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isodigit_0
  (c_7_0 : Int8.t) : Int32.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 126 12 36#
     "expl:Ensures clause"
     (((<>) (Int32.to_int result) (0)) <-> (isodigit (Int8.to_int c_7_0)))) }
  
end

module Function__parse_integer_fixup_radix

  use enum.Uint32 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_IntBase 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val _parse_integer_fixup_radix
  (s_2 : (pointer voidP)) 
   (base : (pointer unsigned_intP)) 
    (unsigned_intP_unsigned_intM_base_6 : ref (memory unsigned_intP
     Uint32.t)) 
     (voidP_s_5_alloc_table : (alloc_table voidP)) 
      (unsigned_intP_base_6_alloc_table : (alloc_table unsigned_intP)) 
       (voidP_s_5_tag_table : (tag_table voidP)) 
        (charP_charM_s_5 : (memory voidP Int8.t)) : (pointer voidP)
         requires { true } reads { unsigned_intP_unsigned_intM_base_6 }
         writes { unsigned_intP_unsigned_intM_base_6 }
         ensures {
           (((allocated voidP_s_5_alloc_table result) ->
             (((=) (typeof voidP_s_5_tag_table result) charP_tag) /\
             (forall i : int.
              ((((<=) (offset_min voidP_s_5_alloc_table result) i) /\
               ((<) i (offset_max voidP_s_5_alloc_table result))) ->
               ((=) (typeof voidP_s_5_tag_table (shift result i)) charP_tag)))))
           /\
           ((((Uint32.(=)
              (select (old !unsigned_intP_unsigned_intM_base_6) base)
              (#"_parse_integer_fixup_radix.jc" 292 35 49#
              "expl:Integer cast" (Uint32.of_int (16))))
             /\
             ((Int8.(=) (select charP_charM_s_5 (shift s_2 (0)))
              (#"_parse_integer_fixup_radix.jc" 293 31 43#
              "expl:Integer cast" (Int8.of_int (48))))
             /\
             ((=)
             (tolower (Int8.to_int (select charP_charM_s_5 (shift s_2 (1)))))
             (Int8.to_int (#"_parse_integer_fixup_radix.jc" 295 15 28#
             "expl:Integer cast" (Int8.of_int (120))))))) ->
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 26 15 37#
             "expl:Ensures clause" ((=) result (shift s_2 (2)))))
           /\
           (((Uint32.(=)
             (select (old !unsigned_intP_unsigned_intM_base_6) base)
             (#"_parse_integer_fixup_radix.jc" 276 33 46# "expl:Integer cast"
             (Uint32.of_int (0)))) ->
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
              "expl:Ensures clause"
              ((is_hex s_2 charP_charM_s_5) ->
               (Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
               (#"_parse_integer_fixup_radix.jc" 279 33 47#
               "expl:Integer cast" (Uint32.of_int (16))))))
             /\
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 20 15 39#
              "expl:Ensures clause"
              ((is_oct s_2 charP_charM_s_5) ->
               (Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
               (#"_parse_integer_fixup_radix.jc" 282 35 48#
               "expl:Integer cast" (Uint32.of_int (8))))))
             /\
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 21 15 40#
              "expl:Ensures clause"
              ((is_dec s_2 charP_charM_s_5) ->
               (Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
               (#"_parse_integer_fixup_radix.jc" 285 37 51#
               "expl:Integer cast" (Uint32.of_int (10))))))
             /\
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 22 15 45#
              "expl:Ensures clause"
              ((is_hex s_2 charP_charM_s_5) -> ((=) result (shift s_2 (2)))))
             /\
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 23 15 54#
             "expl:Ensures clause"
             (((is_oct s_2 charP_charM_s_5) \/ (is_dec s_2 charP_charM_s_5))
              -> ((=) result s_2)))))))))))))
           /\
           ((#"_parse_integer_fixup_radix.jc" 273 10 28#
            "expl:Assigns clause"
            (not_assigns unsigned_intP_base_6_alloc_table
            unsigned_intP_base_6_alloc_table (old
            !unsigned_intP_unsigned_intM_base_6)
            !unsigned_intP_unsigned_intM_base_6 (pset_singleton base)))
           /\
           (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 16 12 44#
           "expl:Ensures clause"
           (((=) result s_2) \/ ((=) result (shift s_2 (2))))))))) }
  
end

module Function__parse_integer_fixup_radix_safe

  use enum.Uint32 
  
  use import Root_unsigned_intP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_IntBase 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val _parse_integer_fixup_radix
  (s_2 : (pointer voidP)) 
   (base : (pointer unsigned_intP)) 
    (unsigned_intP_unsigned_intM_base_6 : ref (memory unsigned_intP
     Uint32.t)) 
     (voidP_s_5_alloc_table : (alloc_table voidP)) 
      (unsigned_intP_base_6_alloc_table : (alloc_table unsigned_intP)) 
       (voidP_s_5_tag_table : (tag_table voidP)) 
        (charP_charM_s_5 : (memory voidP Int8.t)) : (pointer voidP)
         requires {
           ("expl:Internal"
           (#"_parse_integer_fixup_radix.jc" 266 12 409#
           "expl:Requires clause"
           ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 13 13 29#
            "expl:Requires clause"
            (#"_parse_integer_fixup_radix.jc" 266 12 409#
            "expl:Requires clause"
            ((#"_parse_integer_fixup_radix.jc" 266 12 409#
             "expl:Requires clause"
             ((<=) (offset_min voidP_s_5_alloc_table s_2) (0)))
            /\
            (#"_parse_integer_fixup_radix.jc" 266 12 409#
            "expl:Requires clause"
            ((#"_parse_integer_fixup_radix.jc" 266 12 409#
             "expl:Requires clause"
             ((>=) (offset_max voidP_s_5_alloc_table s_2) (2)))
            /\
            (#"_parse_integer_fixup_radix.jc" 266 12 409#
            "expl:Requires clause"
            ((#"_parse_integer_fixup_radix.jc" 266 12 409#
             "expl:Requires clause" ((=) true true))
            /\
            (#"_parse_integer_fixup_radix.jc" 266 12 409#
            "expl:Requires clause"
            ((#"_parse_integer_fixup_radix.jc" 266 12 409#
             "expl:Requires clause" ((=) true true))
            /\
            (#"_parse_integer_fixup_radix.jc" 266 12 409#
            "expl:Requires clause" ((=) true true)))))))))))
           /\
           (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 14 13 25#
           "expl:Requires clause"
           (#"_parse_integer_fixup_radix.jc" 266 12 409#
           "expl:Requires clause"
           ((#"_parse_integer_fixup_radix.jc" 266 12 409#
            "expl:Requires clause"
            ((<=) (offset_min unsigned_intP_base_6_alloc_table base) (0)))
           /\
           (#"_parse_integer_fixup_radix.jc" 266 12 409#
           "expl:Requires clause"
           ((#"_parse_integer_fixup_radix.jc" 266 12 409#
            "expl:Requires clause"
            ((>=) (offset_max unsigned_intP_base_6_alloc_table base) (0)))
           /\
           (#"_parse_integer_fixup_radix.jc" 266 12 409#
           "expl:Requires clause" ((=) true true)))))))))) }
         reads { unsigned_intP_unsigned_intM_base_6 } writes {
         unsigned_intP_unsigned_intM_base_6 }
         ensures {
           (((allocated voidP_s_5_alloc_table result) ->
             (((=) (typeof voidP_s_5_tag_table result) charP_tag) /\
             (forall i : int.
              ((((<=) (offset_min voidP_s_5_alloc_table result) i) /\
               ((<) i (offset_max voidP_s_5_alloc_table result))) ->
               ((=) (typeof voidP_s_5_tag_table (shift result i)) charP_tag)))))
           /\
           ((((Uint32.(=)
              (select (old !unsigned_intP_unsigned_intM_base_6) base)
              (#"_parse_integer_fixup_radix.jc" 292 35 49#
              "expl:Integer cast" (Uint32.of_int (16))))
             /\
             ((Int8.(=) (select charP_charM_s_5 (shift s_2 (0)))
              (#"_parse_integer_fixup_radix.jc" 293 31 43#
              "expl:Integer cast" (Int8.of_int (48))))
             /\
             ((=)
             (tolower (Int8.to_int (select charP_charM_s_5 (shift s_2 (1)))))
             (Int8.to_int (#"_parse_integer_fixup_radix.jc" 295 15 28#
             "expl:Integer cast" (Int8.of_int (120))))))) ->
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 26 15 37#
             "expl:Ensures clause" ((=) result (shift s_2 (2)))))
           /\
           (((Uint32.(=)
             (select (old !unsigned_intP_unsigned_intM_base_6) base)
             (#"_parse_integer_fixup_radix.jc" 276 33 46# "expl:Integer cast"
             (Uint32.of_int (0)))) ->
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
              "expl:Ensures clause"
              ((is_hex s_2 charP_charM_s_5) ->
               (Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
               (#"_parse_integer_fixup_radix.jc" 279 33 47#
               "expl:Integer cast" (Uint32.of_int (16))))))
             /\
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 20 15 39#
              "expl:Ensures clause"
              ((is_oct s_2 charP_charM_s_5) ->
               (Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
               (#"_parse_integer_fixup_radix.jc" 282 35 48#
               "expl:Integer cast" (Uint32.of_int (8))))))
             /\
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 21 15 40#
              "expl:Ensures clause"
              ((is_dec s_2 charP_charM_s_5) ->
               (Uint32.(=) (select !unsigned_intP_unsigned_intM_base_6 base)
               (#"_parse_integer_fixup_radix.jc" 285 37 51#
               "expl:Integer cast" (Uint32.of_int (10))))))
             /\
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 19 15 40#
             "expl:Ensures clause"
             ((#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 22 15 45#
              "expl:Ensures clause"
              ((is_hex s_2 charP_charM_s_5) -> ((=) result (shift s_2 (2)))))
             /\
             (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 23 15 54#
             "expl:Ensures clause"
             (((is_oct s_2 charP_charM_s_5) \/ (is_dec s_2 charP_charM_s_5))
              -> ((=) result s_2)))))))))))))
           /\
           ((#"_parse_integer_fixup_radix.jc" 273 10 28#
            "expl:Assigns clause"
            (not_assigns unsigned_intP_base_6_alloc_table
            unsigned_intP_base_6_alloc_table (old
            !unsigned_intP_unsigned_intM_base_6)
            !unsigned_intP_unsigned_intM_base_6 (pset_singleton base)))
           /\
           (#"/home/work/workspace/self/verker/_parse_integer_fixup_radix.h" 16 12 44#
           "expl:Ensures clause"
           (((=) result s_2) \/ ((=) result (shift s_2 (2))))))))) }
  
end

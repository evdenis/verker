
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

theory Enum__bool_aux

  use why3.Bool.Bool 
  
  function max  : int = (1)
  
  function min  : int = (0)
  
end

theory Enum__bool

  use why3.Bool.Bool 
  
  use import Enum__bool_aux 
  
  clone export enum.Enum with constant min = min, constant max = max
  
end

module Unsafe_enum__bool

  use why3.Bool.Bool 
  
  use import Enum__bool 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_enum__bool

  use why3.Bool.Bool 
  
  use import Enum__bool 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

theory Axiomatic_Ctype

  use enum.Int8 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function tolower int : int
  
  
  axiom A #"/home/work/workspace/self/verker/ctype.h" 59 13 32#
  "expl:Axiom a" :
  (#"/home/work/workspace/self/verker/ctype.h" 59 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 169 21 33# "expl:Integer cast" (Int8.of_int
  (65)))))
  (Int8.to_int (#"strcasecmp.jc" 169 51 63# "expl:Integer cast" (Int8.of_int
  (97))))))
  
  axiom B #"/home/work/workspace/self/verker/ctype.h" 59 43 62#
  "expl:Axiom b" :
  (#"/home/work/workspace/self/verker/ctype.h" 59 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 172 21 33# "expl:Integer cast" (Int8.of_int
  (66)))))
  (Int8.to_int (#"strcasecmp.jc" 172 51 63# "expl:Integer cast" (Int8.of_int
  (98))))))
  
  axiom C_13 #"/home/work/workspace/self/verker/ctype.h" 59 73 92#
  "expl:Axiom c" :
  (#"/home/work/workspace/self/verker/ctype.h" 59 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 175 21 33# "expl:Integer cast" (Int8.of_int
  (67)))))
  (Int8.to_int (#"strcasecmp.jc" 175 51 63# "expl:Integer cast" (Int8.of_int
  (99))))))
  
  axiom D #"/home/work/workspace/self/verker/ctype.h" 60 13 32#
  "expl:Axiom d" :
  (#"/home/work/workspace/self/verker/ctype.h" 60 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 178 21 33# "expl:Integer cast" (Int8.of_int
  (68)))))
  (Int8.to_int (#"strcasecmp.jc" 178 51 64# "expl:Integer cast" (Int8.of_int
  (100))))))
  
  axiom E #"/home/work/workspace/self/verker/ctype.h" 60 43 62#
  "expl:Axiom e" :
  (#"/home/work/workspace/self/verker/ctype.h" 60 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 181 21 33# "expl:Integer cast" (Int8.of_int
  (69)))))
  (Int8.to_int (#"strcasecmp.jc" 181 51 64# "expl:Integer cast" (Int8.of_int
  (101))))))
  
  axiom F #"/home/work/workspace/self/verker/ctype.h" 60 73 92#
  "expl:Axiom f" :
  (#"/home/work/workspace/self/verker/ctype.h" 60 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 184 21 33# "expl:Integer cast" (Int8.of_int
  (70)))))
  (Int8.to_int (#"strcasecmp.jc" 184 51 64# "expl:Integer cast" (Int8.of_int
  (102))))))
  
  axiom G #"/home/work/workspace/self/verker/ctype.h" 61 13 32#
  "expl:Axiom g" :
  (#"/home/work/workspace/self/verker/ctype.h" 61 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 187 21 33# "expl:Integer cast" (Int8.of_int
  (71)))))
  (Int8.to_int (#"strcasecmp.jc" 187 51 64# "expl:Integer cast" (Int8.of_int
  (103))))))
  
  axiom H #"/home/work/workspace/self/verker/ctype.h" 61 43 62#
  "expl:Axiom h" :
  (#"/home/work/workspace/self/verker/ctype.h" 61 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 190 21 33# "expl:Integer cast" (Int8.of_int
  (72)))))
  (Int8.to_int (#"strcasecmp.jc" 190 51 64# "expl:Integer cast" (Int8.of_int
  (104))))))
  
  axiom I_11 #"/home/work/workspace/self/verker/ctype.h" 61 73 92#
  "expl:Axiom i" :
  (#"/home/work/workspace/self/verker/ctype.h" 61 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 193 21 33# "expl:Integer cast" (Int8.of_int
  (73)))))
  (Int8.to_int (#"strcasecmp.jc" 193 51 64# "expl:Integer cast" (Int8.of_int
  (105))))))
  
  axiom J_1 #"/home/work/workspace/self/verker/ctype.h" 62 13 32#
  "expl:Axiom j" :
  (#"/home/work/workspace/self/verker/ctype.h" 62 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 196 21 33# "expl:Integer cast" (Int8.of_int
  (74)))))
  (Int8.to_int (#"strcasecmp.jc" 196 51 64# "expl:Integer cast" (Int8.of_int
  (106))))))
  
  axiom K #"/home/work/workspace/self/verker/ctype.h" 62 43 62#
  "expl:Axiom k" :
  (#"/home/work/workspace/self/verker/ctype.h" 62 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 199 21 33# "expl:Integer cast" (Int8.of_int
  (75)))))
  (Int8.to_int (#"strcasecmp.jc" 199 51 64# "expl:Integer cast" (Int8.of_int
  (107))))))
  
  axiom L #"/home/work/workspace/self/verker/ctype.h" 62 73 92#
  "expl:Axiom l" :
  (#"/home/work/workspace/self/verker/ctype.h" 62 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 202 21 33# "expl:Integer cast" (Int8.of_int
  (76)))))
  (Int8.to_int (#"strcasecmp.jc" 202 51 64# "expl:Integer cast" (Int8.of_int
  (108))))))
  
  axiom M #"/home/work/workspace/self/verker/ctype.h" 63 13 32#
  "expl:Axiom m" :
  (#"/home/work/workspace/self/verker/ctype.h" 63 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 205 21 33# "expl:Integer cast" (Int8.of_int
  (77)))))
  (Int8.to_int (#"strcasecmp.jc" 205 51 64# "expl:Integer cast" (Int8.of_int
  (109))))))
  
  axiom N #"/home/work/workspace/self/verker/ctype.h" 63 43 62#
  "expl:Axiom n" :
  (#"/home/work/workspace/self/verker/ctype.h" 63 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 208 21 33# "expl:Integer cast" (Int8.of_int
  (78)))))
  (Int8.to_int (#"strcasecmp.jc" 208 51 64# "expl:Integer cast" (Int8.of_int
  (110))))))
  
  axiom O #"/home/work/workspace/self/verker/ctype.h" 63 73 92#
  "expl:Axiom o" :
  (#"/home/work/workspace/self/verker/ctype.h" 63 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 211 21 33# "expl:Integer cast" (Int8.of_int
  (79)))))
  (Int8.to_int (#"strcasecmp.jc" 211 51 64# "expl:Integer cast" (Int8.of_int
  (111))))))
  
  axiom P #"/home/work/workspace/self/verker/ctype.h" 64 13 32#
  "expl:Axiom p" :
  (#"/home/work/workspace/self/verker/ctype.h" 64 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 214 21 33# "expl:Integer cast" (Int8.of_int
  (80)))))
  (Int8.to_int (#"strcasecmp.jc" 214 51 64# "expl:Integer cast" (Int8.of_int
  (112))))))
  
  axiom Q #"/home/work/workspace/self/verker/ctype.h" 64 43 62#
  "expl:Axiom q" :
  (#"/home/work/workspace/self/verker/ctype.h" 64 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 217 21 33# "expl:Integer cast" (Int8.of_int
  (81)))))
  (Int8.to_int (#"strcasecmp.jc" 217 51 64# "expl:Integer cast" (Int8.of_int
  (113))))))
  
  axiom R #"/home/work/workspace/self/verker/ctype.h" 64 73 92#
  "expl:Axiom r" :
  (#"/home/work/workspace/self/verker/ctype.h" 64 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 220 21 33# "expl:Integer cast" (Int8.of_int
  (82)))))
  (Int8.to_int (#"strcasecmp.jc" 220 51 64# "expl:Integer cast" (Int8.of_int
  (114))))))
  
  axiom S_11 #"/home/work/workspace/self/verker/ctype.h" 65 13 32#
  "expl:Axiom s" :
  (#"/home/work/workspace/self/verker/ctype.h" 65 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 223 21 33# "expl:Integer cast" (Int8.of_int
  (83)))))
  (Int8.to_int (#"strcasecmp.jc" 223 51 64# "expl:Integer cast" (Int8.of_int
  (115))))))
  
  axiom T #"/home/work/workspace/self/verker/ctype.h" 65 43 62#
  "expl:Axiom t" :
  (#"/home/work/workspace/self/verker/ctype.h" 65 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 226 21 33# "expl:Integer cast" (Int8.of_int
  (84)))))
  (Int8.to_int (#"strcasecmp.jc" 226 51 64# "expl:Integer cast" (Int8.of_int
  (116))))))
  
  axiom U #"/home/work/workspace/self/verker/ctype.h" 65 73 92#
  "expl:Axiom u" :
  (#"/home/work/workspace/self/verker/ctype.h" 65 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 229 21 33# "expl:Integer cast" (Int8.of_int
  (85)))))
  (Int8.to_int (#"strcasecmp.jc" 229 51 64# "expl:Integer cast" (Int8.of_int
  (117))))))
  
  axiom V #"/home/work/workspace/self/verker/ctype.h" 66 13 32#
  "expl:Axiom v" :
  (#"/home/work/workspace/self/verker/ctype.h" 66 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 232 21 33# "expl:Integer cast" (Int8.of_int
  (86)))))
  (Int8.to_int (#"strcasecmp.jc" 232 51 64# "expl:Integer cast" (Int8.of_int
  (118))))))
  
  axiom W #"/home/work/workspace/self/verker/ctype.h" 66 43 62#
  "expl:Axiom w" :
  (#"/home/work/workspace/self/verker/ctype.h" 66 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 235 21 33# "expl:Integer cast" (Int8.of_int
  (87)))))
  (Int8.to_int (#"strcasecmp.jc" 235 51 64# "expl:Integer cast" (Int8.of_int
  (119))))))
  
  axiom X #"/home/work/workspace/self/verker/ctype.h" 66 73 92#
  "expl:Axiom x" :
  (#"/home/work/workspace/self/verker/ctype.h" 66 73 92#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 238 21 33# "expl:Integer cast" (Int8.of_int
  (88)))))
  (Int8.to_int (#"strcasecmp.jc" 238 51 64# "expl:Integer cast" (Int8.of_int
  (120))))))
  
  axiom Y #"/home/work/workspace/self/verker/ctype.h" 67 13 32#
  "expl:Axiom y" :
  (#"/home/work/workspace/self/verker/ctype.h" 67 13 32#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 241 21 33# "expl:Integer cast" (Int8.of_int
  (89)))))
  (Int8.to_int (#"strcasecmp.jc" 241 51 64# "expl:Integer cast" (Int8.of_int
  (121))))))
  
  axiom Z #"/home/work/workspace/self/verker/ctype.h" 67 43 62#
  "expl:Axiom z" :
  (#"/home/work/workspace/self/verker/ctype.h" 67 43 62#
  ((=)
  (tolower
  (Int8.to_int (#"strcasecmp.jc" 244 21 33# "expl:Integer cast" (Int8.of_int
  (90)))))
  (Int8.to_int (#"strcasecmp.jc" 244 51 64# "expl:Integer cast" (Int8.of_int
  (122))))))
  
  predicate isupper (c_0 : int)
  =
     (((<=)
      (Int8.to_int (#"strcasecmp.jc" 135 5 17# "expl:Integer cast"
      (Int8.of_int (65)))) c_0)
     /\
     ((<=) c_0
     (Int8.to_int (#"strcasecmp.jc" 135 50 62# "expl:Integer cast"
     (Int8.of_int (90))))))
  
  
  axiom Pl #"/home/work/workspace/self/verker/ctype.h" 69 14 64#
  "expl:Axiom pl" :
  (#"/home/work/workspace/self/verker/ctype.h" 69 14 64#
  (forall c_9_0 : int.
   ((not (isupper c_9_0)) -> ((=) (tolower c_9_0) c_9_0))))
  
  predicate islower (c : int)
  =
     (((<=)
      (Int8.to_int (#"strcasecmp.jc" 132 5 17# "expl:Integer cast"
      (Int8.of_int (97)))) c)
     /\
     ((<=) c
     (Int8.to_int (#"strcasecmp.jc" 132 46 59# "expl:Integer cast"
     (Int8.of_int (122))))))
  
  
  function toupper int : int
  
  
  axiom Pu #"/home/work/workspace/self/verker/ctype.h" 70 14 64#
  "expl:Axiom pu" :
  (#"/home/work/workspace/self/verker/ctype.h" 70 14 64#
  (forall c_10_0 : int.
   ((not (islower c_10_0)) -> ((=) (toupper c_10_0) c_10_0))))
  
  axiom Tl #"/home/work/workspace/self/verker/ctype.h" 71 14 73#
  "expl:Axiom tl" :
  (#"/home/work/workspace/self/verker/ctype.h" 71 14 73#
  (forall c_11_1 : int.
   ((not (islower c_11_1)) -> ((=) (toupper (tolower c_11_1)) c_11_1))))
  
  axiom Tu #"/home/work/workspace/self/verker/ctype.h" 72 14 73#
  "expl:Axiom tu" :
  (#"/home/work/workspace/self/verker/ctype.h" 72 14 73#
  (forall c_12_0 : int.
   ((not (isupper c_12_0)) -> ((=) (tolower (toupper c_12_0)) c_12_0))))
  
  predicate isspace (c_5 : int)
  =
     (((=) c_5
      (Int8.to_int (#"strcasecmp.jc" 150 16 28# "expl:Integer cast"
      (Int8.of_int (32)))))
     \/
     (((=) c_5
      (Int8.to_int (#"strcasecmp.jc" 151 17 29# "expl:Integer cast"
      (Int8.of_int (12)))))
     \/
     (((=) c_5
      (Int8.to_int (#"strcasecmp.jc" 152 16 28# "expl:Integer cast"
      (Int8.of_int (10)))))
     \/
     (((=) c_5
      (Int8.to_int (#"strcasecmp.jc" 153 15 27# "expl:Integer cast"
      (Int8.of_int (13)))))
     \/
     (((=) c_5
      (Int8.to_int (#"strcasecmp.jc" 154 14 25# "expl:Integer cast"
      (Int8.of_int (9)))))
     \/
     ((=) c_5
     (Int8.to_int (#"strcasecmp.jc" 155 13 25# "expl:Integer cast"
     (Int8.of_int (11))))))))))
  
  
  predicate isdigit (c_2 : int)
  =
     (((<=)
      (Int8.to_int (#"strcasecmp.jc" 141 5 17# "expl:Integer cast"
      (Int8.of_int (48)))) c_2)
     /\
     ((<=) c_2
     (Int8.to_int (#"strcasecmp.jc" 141 50 62# "expl:Integer cast"
     (Int8.of_int (57))))))
  
  
  predicate isalpha (c_1 : int) = ((isupper c_1) \/ (islower c_1))
  
  
  predicate isalnum (c_4 : int) = ((isdigit c_4) \/ (isalpha c_4))
  
  
  predicate isxdigit (c_6 : int)
  =
     ((isdigit c_6) \/
     ((((<=)
       (Int8.to_int (#"strcasecmp.jc" 159 8 20# "expl:Integer cast"
       (Int8.of_int (97)))) c_6)
      /\
      ((<=) c_6
      (Int8.to_int (#"strcasecmp.jc" 160 16 29# "expl:Integer cast"
      (Int8.of_int (102))))))
     \/
     (((<=)
      (Int8.to_int (#"strcasecmp.jc" 161 7 19# "expl:Integer cast"
      (Int8.of_int (65)))) c_6)
     /\
     ((<=) c_6
     (Int8.to_int (#"strcasecmp.jc" 162 15 27# "expl:Integer cast"
     (Int8.of_int (70))))))))
  
  
  predicate isodigit (c_3 : int)
  =
     (((<=)
      (Int8.to_int (#"strcasecmp.jc" 144 5 17# "expl:Integer cast"
      (Int8.of_int (48)))) c_3)
     /\
     ((<=) c_3
     (Int8.to_int (#"strcasecmp.jc" 144 50 62# "expl:Integer cast"
     (Int8.of_int (55))))))
  
  
end

theory Axiomatic_Strlen

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate valid_str (s : (pointer voidP)) (voidP_s_2_alloc_table_at_L :
  (alloc_table voidP)) (charP_charM_s_2_at_L : (memory voidP Int8.t))
  =
     (exists n_1 : Uint64.t.
      ((Int8.(=) (select charP_charM_s_2_at_L (shift s (Uint64.to_int n_1)))
       (#"strcasecmp.jc" 23 42 53# "expl:Integer cast" (Int8.of_int (0))))
      /\
      (if ((<=) (0) (Uint64.to_int n_1)) then
       (((<=) (offset_min voidP_s_2_alloc_table_at_L s) (0)) /\
       (((>=) (offset_max voidP_s_2_alloc_table_at_L s) (Uint64.to_int n_1))
       /\
       (forall __framac_tmp1 : int.
        ((((<=) (0) __framac_tmp1) /\
         ((<=) __framac_tmp1 (Uint64.to_int n_1))) -> ((=) true true)))))
       else ((=) true true))))
  
  
  lemma Valid_str_shift1
  #"/home/work/workspace/self/verker/strlen.h" 12 7 102#
  "expl:Lemma valid_str_shift1" :
  (forall voidP_s_0_7_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_0_7_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 12 7 102#
    (forall s_0_0 : (pointer voidP).
     (((Int8.(<>) (select charP_charM_s_0_7_at_L s_0_0)
       (#"strcasecmp.jc" 37 28 39# "expl:Integer cast" (Int8.of_int (0))))
      /\
      (valid_str s_0_0 voidP_s_0_7_alloc_table_at_L charP_charM_s_0_7_at_L))
      ->
      (valid_str (shift s_0_0 (1)) voidP_s_0_7_alloc_table_at_L
      charP_charM_s_0_7_at_L))))))
  
  lemma Valid_str_strend
  #"/home/work/workspace/self/verker/strlen.h" 18 7 87#
  "expl:Lemma valid_str_strend" :
  (forall voidP_s_1_8_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_1_8_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 18 7 87#
    (forall s_1 : (pointer voidP).
     (((((<=) (offset_min voidP_s_1_8_alloc_table_at_L s_1) (0)) /\
       (((>=) (offset_max voidP_s_1_8_alloc_table_at_L s_1) (0)) /\
       ((=) true true)))
      /\
      (Int8.(=) (select charP_charM_s_1_8_at_L s_1)
      (#"strcasecmp.jc" 45 29 40# "expl:Integer cast" (Int8.of_int (0))))) ->
      (valid_str s_1 voidP_s_1_8_alloc_table_at_L charP_charM_s_1_8_at_L))))))
  
  function strlen (s_2 : (pointer voidP)) (charP_charM_s_2_3_at_L : (memory
  voidP Int8.t)) : Uint64.t
  =
     (if
      (Int8.(=) (select charP_charM_s_2_3_at_L (shift s_2 (0)))
      (#"strcasecmp.jc" 49 30 41# "expl:Integer cast" (Int8.of_int (0))))
      then (#"strcasecmp.jc" 49 48 61# "expl:Integer cast" (Uint64.of_int
      (0))) else (#"strcasecmp.jc" 49 67 255# "expl:Integer cast"
      (Uint64.of_int
      (Int.(+) (1)
      (Uint64.to_int (strlen (shift s_2 (1)) charP_charM_s_2_3_at_L))))))
  
  
  lemma Strlen_before_null
  #"/home/work/workspace/self/verker/strlen.h" 26 7 106#
  "expl:Lemma strlen_before_null" :
  (forall voidP_s_3_9_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_3_9_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 26 7 106#
    (forall s_3 : (pointer voidP).
     (forall i : int.
      (((valid_str s_3 voidP_s_3_9_alloc_table_at_L charP_charM_s_3_9_at_L)
       /\
       (((<=) (0) i) /\
       ((<) i (Uint64.to_int (strlen s_3 charP_charM_s_3_9_at_L))))) ->
       (Int8.(<>) (select charP_charM_s_3_9_at_L (shift s_3 i))
       (#"strcasecmp.jc" 58 36 47# "expl:Integer cast" (Int8.of_int (0))))))))))
  
  lemma Strlen_at_null #"/home/work/workspace/self/verker/strlen.h" 31 7 71#
  "expl:Lemma strlen_at_null" :
  (forall voidP_s_4_10_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_4_10_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 31 7 71#
    (forall s_4 : (pointer voidP).
     ((valid_str s_4 voidP_s_4_10_alloc_table_at_L charP_charM_s_4_10_at_L)
      ->
      (Int8.(=)
      (select charP_charM_s_4_10_at_L
      (shift s_4 (Uint64.to_int (strlen s_4 charP_charM_s_4_10_at_L))))
      (#"strcasecmp.jc" 63 60 71# "expl:Integer cast" (Int8.of_int (0)))))))))
  
  lemma Strlen_shift #"/home/work/workspace/self/verker/strlen.h" 35 7 125#
  "expl:Lemma strlen_shift" :
  (forall voidP_s_5_11_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_5_11_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 35 7 125#
    (forall s_5 : (pointer voidP).
     (forall i_0 : Uint64.t.
      (((valid_str s_5 voidP_s_5_11_alloc_table_at_L charP_charM_s_5_11_at_L)
       /\ (Uint64.(<=) i_0 (strlen s_5 charP_charM_s_5_11_at_L))) ->
       ((=)
       (Uint64.to_int
       (strlen (shift s_5 (Uint64.to_int i_0)) charP_charM_s_5_11_at_L))
       (Int.(-) (Uint64.to_int (strlen s_5 charP_charM_s_5_11_at_L))
       (Uint64.to_int i_0)))))))))
  
  lemma Strlen_shift_ex
  #"/home/work/workspace/self/verker/strlen.h" 41 7 126#
  "expl:Lemma strlen_shift_ex" :
  (forall voidP_s_6_12_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_6_12_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 41 7 126#
    (forall s_6 : (pointer voidP).
     (forall i_1 : Uint64.t.
      (((valid_str s_6 voidP_s_6_12_alloc_table_at_L charP_charM_s_6_12_at_L)
       /\
       ((Uint64.(<) (#"strcasecmp.jc" 75 39 52# "expl:Integer cast"
        (Uint64.of_int (0))) i_1)
       /\ (Uint64.(<=) i_1 (strlen s_6 charP_charM_s_6_12_at_L)))) ->
       (Uint64.(<)
       (strlen (shift s_6 (Uint64.to_int i_1)) charP_charM_s_6_12_at_L)
       (strlen s_6 charP_charM_s_6_12_at_L))))))))
  
  lemma Strlen_shift1 #"/home/work/workspace/self/verker/strlen.h" 47 7 103#
  "expl:Lemma strlen_shift1" :
  (forall voidP_s_7_13_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_7_13_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 47 7 103#
    (forall s_7 : (pointer voidP).
     (((valid_str s_7 voidP_s_7_13_alloc_table_at_L charP_charM_s_7_13_at_L)
      /\
      (Int8.(<>) (select charP_charM_s_7_13_at_L s_7)
      (#"strcasecmp.jc" 81 49 60# "expl:Integer cast" (Int8.of_int (0))))) ->
      ((=) (Uint64.to_int (strlen s_7 charP_charM_s_7_13_at_L))
      (Int.(+) (1)
      (Uint64.to_int (strlen (shift s_7 (1)) charP_charM_s_7_13_at_L)))))))))
  
  lemma Strlen_pointers
  #"/home/work/workspace/self/verker/strlen.h" 52 7 254#
  "expl:Lemma strlen_pointers" :
  (forall voidP_s_8_14_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_8_14_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 52 7 254#
    (forall s_8 : (pointer voidP).
     (forall sc : (pointer voidP).
      (((valid_str s_8 voidP_s_8_14_alloc_table_at_L charP_charM_s_8_14_at_L)
       /\
       ((valid_str sc voidP_s_8_14_alloc_table_at_L charP_charM_s_8_14_at_L)
       /\
       ((same_block s_8 sc) /\
       ((same_block s_8 sc) /\
       (((<=) (sub_pointer s_8 sc) (0)) /\
       (forall i_2 : int.
        ((((<=) (0) i_2) /\ ((<=) i_2 (sub_pointer sc s_8))) ->
         (Int8.(<>) (select charP_charM_s_8_14_at_L (shift s_8 i_2))
         (#"strcasecmp.jc" 94 43 54# "expl:Integer cast" (Int8.of_int (0)))))))))))
       ->
       (Uint64.(<=) (strlen sc charP_charM_s_8_14_at_L)
       (strlen s_8 charP_charM_s_8_14_at_L))))))))
  
  lemma Strlen_main #"/home/work/workspace/self/verker/strlen.h" 61 7 165#
  "expl:Lemma strlen_main" :
  (forall voidP_s_9_16_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_9_16_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 61 7 165#
    (forall s_9 : (pointer voidP).
     (forall n_2 : Uint64.t.
      (((valid_str s_9 voidP_s_9_16_alloc_table_at_L charP_charM_s_9_16_at_L)
       /\
       ((Int8.(=)
        (select charP_charM_s_9_16_at_L (shift s_9 (Uint64.to_int n_2)))
        (#"strcasecmp.jc" 101 53 64# "expl:Integer cast" (Int8.of_int (0))))
       /\
       (forall i_3 : int.
        ((((<=) (0) i_3) /\ ((<) i_3 (Uint64.to_int n_2))) ->
         (Int8.(<>) (select charP_charM_s_9_16_at_L (shift s_9 i_3))
         (#"strcasecmp.jc" 104 43 54# "expl:Integer cast" (Int8.of_int (0))))))))
       -> (Uint64.(=) (strlen s_9 charP_charM_s_9_16_at_L) n_2)))))))
  
  lemma Valid_str_shiftn
  #"/home/work/workspace/self/verker/strlen.h" 68 7 123#
  "expl:Lemma valid_str_shiftn" :
  (forall voidP_s_10_17_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_10_17_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker/strlen.h" 68 7 123#
    (forall s_10 : (pointer voidP).
     (forall i_4 : int.
      (((valid_str s_10 voidP_s_10_17_alloc_table_at_L
        charP_charM_s_10_17_at_L)
       /\
       (((<=) (0) i_4) /\
       ((<) i_4 (Uint64.to_int (strlen s_10 charP_charM_s_10_17_at_L))))) ->
       (valid_str (shift s_10 i_4) voidP_s_10_17_alloc_table_at_L
       charP_charM_s_10_17_at_L)))))))
  
end

module Function_tolower_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val tolower_0
  (c_11_0 : Int8.t) : Int8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 112 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (tolower (Int8.to_int c_11_0)))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_while_0_break_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_strcasecmp_safety
#"/home/work/workspace/self/verker/strcasecmp.c" 3 4 46#
"expl:strcasecmp, safety"

  use enum.Uint64 
  
  use Safe_int8 
  
  use Safe_int32_of_Safe_int8 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_tolower_0_safe 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  let strcasecmp #"/home/work/workspace/self/verker/strcasecmp.c" 3 4 46#
  "expl:Function strcasecmp, safety" =
  fun
   (s1 : (pointer voidP)) (s2 : (pointer voidP)) (voidP_s1_5_alloc_table :
   (alloc_table voidP)) (voidP_s2_6_alloc_table : (alloc_table voidP))
   (voidP_s2_6_tag_table : (tag_table voidP)) (voidP_s1_5_tag_table :
   (tag_table voidP)) (charP_charM_s1_5 : (memory voidP Int8.t))
   (charP_charM_s2_6 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_s2_6_alloc_table s2) ->
     (((=) (typeof voidP_s2_6_tag_table s2) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s2_6_alloc_table s2) i) /\
       ((<) i (offset_max voidP_s2_6_alloc_table s2))) ->
       ((=) (typeof voidP_s2_6_tag_table (shift s2 i)) charP_tag)))))
   /\
   (((allocated voidP_s1_5_alloc_table s1) ->
     (((=) (typeof voidP_s1_5_tag_table s1) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s1_5_alloc_table s1) i) /\
       ((<) i (offset_max voidP_s1_5_alloc_table s1))) ->
       ((=) (typeof voidP_s1_5_tag_table (shift s1 i)) charP_tag)))))
   /\
   (#"strcasecmp.jc" 355 12 76#
   ((#"/home/work/workspace/self/verker/strcasecmp.h" 8 13 26#
    (valid_str s1 voidP_s1_5_alloc_table charP_charM_s1_5))
   /\
   (#"/home/work/workspace/self/verker/strcasecmp.h" 9 13 26#
   (valid_str s2 voidP_s2_6_alloc_table charP_charM_s2_6)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   (let mutable_s1 = ref s1 in
   (let mutable_s2 = ref s2 in
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (); ();
     (let c1 = ref (Safe_int32.any_  () ) in
     (let c2 = ref (Safe_int32.any_  () ) in
     (let os1 = ref (any_pointer  () : (pointer voidP)) in
     (let os2 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (Safe_int8.any_  () ) in
     (let tmp_1 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_2 = ref (Safe_int8.any_  () ) in
     (let res = ref (Safe_int32.any_  () ) in
     (let __retres = ref (Safe_int32.any_  () ) in
     try
      begin
      (os1 :=
       (let _jessie_60 = !mutable_s1 in
       begin
       (assert {
       (#"/home/work/workspace/self/verker/strcasecmp.c" 6 17 20#
       "expl:Pointer index bounds" true) }); _jessie_60 end));
       begin
       (os2 :=
        (let _jessie_49 = !mutable_s2 in
        begin
        (assert {
        (#"/home/work/workspace/self/verker/strcasecmp.c" 7 17 20#
        "expl:Pointer index bounds" true) }); _jessie_49 end));
        'Loop_4:
        loop
        invariant { (#"strcasecmp.jc" 432 6 3008# true) }
          variant {
            (#"/home/work/workspace/self/verker/strcasecmp.c" 15 18 42#
            (Int.(-) (Uint64.to_int (strlen !os1 charP_charM_s1_5))
            (sub_pointer !mutable_s1 !os1))) }
         begin
         any unit
         requires { true } reads { mutable_s1, mutable_s2 }
         ensures {
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 13 20 115#
            (forall i_9 : int.
             ((((<=) (0) i_9) /\ ((<) i_9 (sub_pointer !mutable_s1 !os1))) ->
              ((=)
              (tolower
              (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_9))))
              (tolower
              (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_9))))))))
           /\
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 12 20 40#
            ((=) (sub_pointer !mutable_s1 !os1)
            (sub_pointer !mutable_s2 !os2)))
           /\
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 29#
             (same_block !os2 !mutable_s2))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 29#
             ((<=) (sub_pointer !os2 !mutable_s2) (0)))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 27 50#
             (same_block !mutable_s2
             (shift !os2 (Uint64.to_int (strlen !os2 charP_charM_s2_6)))))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 27 50#
            ((<=)
            (sub_pointer !mutable_s2
            (shift !os2 (Uint64.to_int (strlen !os2 charP_charM_s2_6)))) (0))))))))))
           /\
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 29#
             (same_block !os1 !mutable_s1))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 29#
             ((<=) (sub_pointer !os1 !mutable_s1) (0)))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 27 50#
             (same_block !mutable_s1
             (shift !os1 (Uint64.to_int (strlen !os1 charP_charM_s1_5)))))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 27 50#
            ((<=)
            (sub_pointer !mutable_s1
            (shift !os1 (Uint64.to_int (strlen !os1 charP_charM_s1_5)))) (0))))))))))
           /\
           (#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 50#
           (#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 50#
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 33#
            (valid_str !mutable_s1 voidP_s1_5_alloc_table charP_charM_s1_5))
           /\
           (#"/home/work/workspace/self/verker/strcasecmp.c" 9 37 50#
           (valid_str !mutable_s2 voidP_s2_6_alloc_table charP_charM_s2_6)))))))))
           } ;
          try
           begin
           begin
           begin
           begin
           begin
           begin
           (tmp :=
            (let _jessie_50 = !mutable_s1 in
            begin
            (assert {
            (#"/home/work/workspace/self/verker/strcasecmp.c" 18 16 20#
            "expl:Pointer index bounds" true) }); _jessie_50 end));
            begin
            (mutable_s1 :=
             (let _jessie_51 =
             (shift_typesafe  !mutable_s1
              (Safe_int32.to_int 
               (#"strcasecmp.jc" 473 54 66# "expl:Integer cast"
               (Safe_int32.of_int (1))) ) ) in
             begin
             (assert {
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 16 20#
             "expl:Pointer index bounds" true) }); _jessie_51 end)); () end
           end;
            (tmp_0 :=
             (let _jessie_52 =
             (let _jessie_53 =
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 15 20#
             "expl:Pointer dereference"
             (acc  voidP_s1_5_alloc_table charP_charM_s1_5 !tmp )) in
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 7 21#
             "expl:Precondition for tolower"
             (Function_tolower_0_safe.tolower_0  _jessie_53 ))) in
             begin
             (assert {
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 7 21#
             "expl:Pointer index bounds" true) }); _jessie_52 end)) end;
            (c1 :=
             (let _jessie_54 =
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 7 21#
             "expl:Integer cast" (Safe_int32_of_Safe_int8.cast  !tmp_0 )) in
             begin
             (assert {
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 2 21#
             "expl:Pointer index bounds" true) }); _jessie_54 end)) end;
            begin
            begin
            begin
            (tmp_1 :=
             (let _jessie_55 = !mutable_s2 in
             begin
             (assert {
             (#"/home/work/workspace/self/verker/strcasecmp.c" 19 16 20#
             "expl:Pointer index bounds" true) }); _jessie_55 end));
             begin
             (mutable_s2 :=
              (let _jessie_56 =
              (shift_typesafe  !mutable_s2
               (Safe_int32.to_int 
                (#"strcasecmp.jc" 484 54 66# "expl:Integer cast"
                (Safe_int32.of_int (1))) ) ) in
              begin
              (assert {
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 16 20#
              "expl:Pointer index bounds" true) }); _jessie_56 end)); () end
            end;
             (tmp_2 :=
              (let _jessie_57 =
              (let _jessie_58 =
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 15 20#
              "expl:Pointer dereference"
              (acc  voidP_s2_6_alloc_table charP_charM_s2_6 !tmp_1 )) in
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 7 21#
              "expl:Precondition for tolower"
              (Function_tolower_0_safe.tolower_0  _jessie_58 ))) in
              begin
              (assert {
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 7 21#
              "expl:Pointer index bounds" true) }); _jessie_57 end)) end;
             (c2 :=
              (let _jessie_59 =
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 7 21#
              "expl:Integer cast" (Safe_int32_of_Safe_int8.cast  !tmp_2 )) in
              begin
              (assert {
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 2 21#
              "expl:Pointer index bounds" true) }); _jessie_59 end)) end end;
            (if
            (#"/home/work/workspace/self/verker/strcasecmp.c" 20 10 18#
            (Safe_int32.(=)  !c1 !c2 ))
            then
             (if
             (#"/home/work/workspace/self/verker/strcasecmp.c" 20 22 29#
             (Safe_int32.(<>)  !c1
              (#"strcasecmp.jc" 492 63 75# "expl:Integer cast"
              (Safe_int32.of_int (0))) )) then ()
             else (raise (Goto_while_0_break_exc ())))
            else (raise (Goto_while_0_break_exc ()))) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end end with Goto_while_0_break_exc _jessie_1 ->
      'While_0_break:
      'While_0_break:
      begin
      ();
       begin
       (res :=
        (let _jessie_61 = (Safe_int32.(-)  !c1 !c2 ) in
        begin
        (assert {
        (#"/home/work/workspace/self/verker/strcasecmp.c" 21 15 18#
        "expl:Pointer index bounds" true) }); _jessie_61 end));
        begin
        any unit
        requires { true }
        ensures {
          (#"/home/work/workspace/self/verker/strcasecmp.c" 22 12 44#
          ((Int32.(=) !c1 !c2) ->
           ((Int32.(=) !c1 (#"strcasecmp.jc" 502 60 72# "expl:Integer cast"
            (Int32.of_int (0))))
           /\
           (Int32.(=) !res (#"strcasecmp.jc" 503 62 74# "expl:Integer cast"
           (Int32.of_int (0))))))) } ; () end;
        begin
        any unit
        requires { true } reads { mutable_s1 }
        ensures {
          (#"/home/work/workspace/self/verker/strcasecmp.c" 23 12 289#
          ((Int32.(<>) !c1 !c2) ->
           (exists i_10 : int.
            (((<=) (0) i_10) /\
            (((<=) i_10 (Uint64.to_int (strlen !os1 charP_charM_s1_5))) /\
            ((forall j_0 : int.
              ((((<=) (0) j_0) /\ ((<) j_0 i_10)) ->
               ((=)
               (tolower
               (Int8.to_int (select charP_charM_s1_5 (shift !os1 j_0))))
               (tolower
               (Int8.to_int (select charP_charM_s2_6 (shift !os2 j_0)))))))
            /\
            (((<>)
             (tolower
             (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_10))))
             (tolower
             (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_10)))))
            /\
            (((=) (Int32.to_int !res)
             (Int.(-)
             (tolower
             (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_10))))
             (tolower
             (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_10))))))
            /\ ((=) i_10 (Int.(-) (sub_pointer !mutable_s1 !os1) (1)))))))))))
          } ; () end;
        begin
        (__retres :=
         (let _jessie_62 = (Safe_int32.(-)  !c1 !c2 ) in
         begin
         (assert {
         (#"/home/work/workspace/self/verker/strcasecmp.c" 30 1 16#
         "expl:Pointer index bounds" true) }); _jessie_62 end));
         begin
         (return :=
          (let _jessie_63 = !__retres in
          begin
          (assert {
          (#"strcasecmp.jc" 537 7 22# "expl:Pointer index bounds" true) });
           _jessie_63 end)); (raise Return) end end end end end))))))))));
     absurd  end with Return -> !return end)))
  
end

module Function_tolower_0

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val tolower_0
  (c_11_0 : Int8.t) : Int8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 112 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (tolower (Int8.to_int c_11_0)))) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Function_strcasecmp_behaviors
#"/home/work/workspace/self/verker/strcasecmp.c" 3 4 46#
"expl:strcasecmp, behaviors"

  use Unsafe_int8 
  
  use Unsafe_int32_of_Unsafe_int8 
  
  use Unsafe_int32 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_tolower_0 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  let strcasecmp_ensures_default
  #"/home/work/workspace/self/verker/strcasecmp.c" 3 4 46#
  "expl:Function strcasecmp, default behavior" =
  fun
   (s1 : (pointer voidP)) (s2 : (pointer voidP)) (voidP_s1_5_alloc_table :
   (alloc_table voidP)) (voidP_s2_6_alloc_table : (alloc_table voidP))
   (voidP_s2_6_tag_table : (tag_table voidP)) (voidP_s1_5_tag_table :
   (tag_table voidP)) (charP_charM_s1_5 : (memory voidP Int8.t))
   (charP_charM_s2_6 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_s2_6_alloc_table s2) ->
     (((=) (typeof voidP_s2_6_tag_table s2) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s2_6_alloc_table s2) i) /\
       ((<) i (offset_max voidP_s2_6_alloc_table s2))) ->
       ((=) (typeof voidP_s2_6_tag_table (shift s2 i)) charP_tag)))))
   /\
   (((allocated voidP_s1_5_alloc_table s1) ->
     (((=) (typeof voidP_s1_5_tag_table s1) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s1_5_alloc_table s1) i) /\
       ((<) i (offset_max voidP_s1_5_alloc_table s1))) ->
       ((=) (typeof voidP_s1_5_tag_table (shift s1 i)) charP_tag)))))
   /\
   (#"strcasecmp.jc" 355 12 76#
   ((#"/home/work/workspace/self/verker/strcasecmp.h" 8 13 26#
    (valid_str s1 voidP_s1_5_alloc_table charP_charM_s1_5))
   /\
   (#"/home/work/workspace/self/verker/strcasecmp.h" 9 13 26#
   (valid_str s2 voidP_s2_6_alloc_table charP_charM_s2_6)))))) }
   ensures { ("expl:Postcondition" ("expl:Ensures clause" true)) } diverges 
   ->
   (let mutable_s1 = ref s1 in
   (let mutable_s2 = ref s2 in
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (check {
    (#"strcasecmp.jc" 385 10 824# "expl:Behavior disjointness check"
    (not
    ((forall i_8_0 : int.
      ((((<=) (0) i_8_0) /\
       ((<=) i_8_0 (Uint64.to_int (strlen !mutable_s1 charP_charM_s1_5)))) ->
       ((=)
       (tolower
       (Int8.to_int (select charP_charM_s1_5 (shift !mutable_s1 i_8_0))))
       (tolower
       (Int8.to_int (select charP_charM_s2_6 (shift !mutable_s2 i_8_0)))))))
    /\
    (exists i_6_0 : int.
     (((<=) (0) i_6_0) /\
     (((<=) i_6_0 (Uint64.to_int (strlen !mutable_s1 charP_charM_s1_5))) /\
     ((<>)
     (tolower
     (Int8.to_int (select charP_charM_s1_5 (shift !mutable_s1 i_6_0))))
     (tolower
     (Int8.to_int (select charP_charM_s2_6 (shift !mutable_s2 i_6_0)))))))))))
    });
     (check {
     (#"strcasecmp.jc" 398 10 706# "expl:Behavior completeness check"
     ((exists i_6_1 : int.
       (((<=) (0) i_6_1) /\
       (((<=) i_6_1 (Uint64.to_int (strlen !mutable_s1 charP_charM_s1_5))) /\
       ((<>)
       (tolower
       (Int8.to_int (select charP_charM_s1_5 (shift !mutable_s1 i_6_1))))
       (tolower
       (Int8.to_int (select charP_charM_s2_6 (shift !mutable_s2 i_6_1))))))))
     \/
     (forall i_8_1 : int.
      ((((<=) (0) i_8_1) /\
       ((<=) i_8_1 (Uint64.to_int (strlen !mutable_s1 charP_charM_s1_5)))) ->
       ((=)
       (tolower
       (Int8.to_int (select charP_charM_s1_5 (shift !mutable_s1 i_8_1))))
       (tolower
       (Int8.to_int (select charP_charM_s2_6 (shift !mutable_s2 i_8_1)))))))))
     });
     (let c1 = ref (Unsafe_int32.any_  () ) in
     (let c2 = ref (Unsafe_int32.any_  () ) in
     (let os1 = ref (any_pointer  () : (pointer voidP)) in
     (let os2 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (Unsafe_int8.any_  () ) in
     (let tmp_1 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_2 = ref (Unsafe_int8.any_  () ) in
     (let res = ref (Unsafe_int32.any_  () ) in
     (let __retres = ref (Unsafe_int32.any_  () ) in
     try
      begin
      (os1 := !mutable_s1);
       begin
       (os2 := !mutable_s2);
        'Loop_1:
        loop
        invariant
          { ((#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 50#
             (#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 50#
             ((#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 33#
              (valid_str !mutable_s1 voidP_s1_5_alloc_table charP_charM_s1_5))
             /\
             (#"/home/work/workspace/self/verker/strcasecmp.c" 9 37 50#
             (valid_str !mutable_s2 voidP_s2_6_alloc_table charP_charM_s2_6)))))
            &&
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
             (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
             ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 29#
              (same_block !os1 !mutable_s1))
             /\
             (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
             ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 29#
              ((<=) (sub_pointer !os1 !mutable_s1) (0)))
             /\
             (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
             ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 27 50#
              (same_block !mutable_s1
              (shift !os1 (Uint64.to_int (strlen !os1 charP_charM_s1_5)))))
             /\
             (#"/home/work/workspace/self/verker/strcasecmp.c" 10 27 50#
             ((<=)
             (sub_pointer !mutable_s1
             (shift !os1 (Uint64.to_int (strlen !os1 charP_charM_s1_5))))
             (0))))))))))
            &&
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
             (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
             ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 29#
              (same_block !os2 !mutable_s2))
             /\
             (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
             ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 29#
              ((<=) (sub_pointer !os2 !mutable_s2) (0)))
             /\
             (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
             ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 27 50#
              (same_block !mutable_s2
              (shift !os2 (Uint64.to_int (strlen !os2 charP_charM_s2_6)))))
             /\
             (#"/home/work/workspace/self/verker/strcasecmp.c" 11 27 50#
             ((<=)
             (sub_pointer !mutable_s2
             (shift !os2 (Uint64.to_int (strlen !os2 charP_charM_s2_6))))
             (0))))))))))
            &&
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 12 20 40#
             ((=) (sub_pointer !mutable_s1 !os1)
             (sub_pointer !mutable_s2 !os2)))
            &&
            (#"/home/work/workspace/self/verker/strcasecmp.c" 13 20 115#
            (forall i_9 : int.
             ((((<=) (0) i_9) /\ ((<) i_9 (sub_pointer !mutable_s1 !os1))) ->
              ((=)
              (tolower
              (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_9))))
              (tolower
              (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_9)))))))))))) }
          
         begin
         any unit requires { true } ensures { true } ;
          try
           begin
           begin
           begin
           begin
           begin
           begin
           (tmp := !mutable_s1);
            begin
            (mutable_s1 :=
             (shift_  !mutable_s1
              (Unsafe_int32.to_int 
               (#"strcasecmp.jc" 473 54 66# "expl:Integer cast"
               (Unsafe_int32.of_int (1))) ) )); () end end;
            (tmp_0 :=
             (let _jessie_8 = (acc  charP_charM_s1_5 !tmp ) in
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 7 21#
             "expl:Precondition for tolower"
             (Function_tolower_0.tolower_0  _jessie_8 )))) end;
            (c1 :=
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 7 21#
             "expl:Integer cast" (Unsafe_int32_of_Unsafe_int8.cast  !tmp_0 )))
           end;
            begin
            begin
            begin
            (tmp_1 := !mutable_s2);
             begin
             (mutable_s2 :=
              (shift_  !mutable_s2
               (Unsafe_int32.to_int 
                (#"strcasecmp.jc" 484 54 66# "expl:Integer cast"
                (Unsafe_int32.of_int (1))) ) )); () end end;
             (tmp_2 :=
              (let _jessie_13 = (acc  charP_charM_s2_6 !tmp_1 ) in
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 7 21#
              "expl:Precondition for tolower"
              (Function_tolower_0.tolower_0  _jessie_13 )))) end;
             (c2 :=
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 7 21#
              "expl:Integer cast"
              (Unsafe_int32_of_Unsafe_int8.cast  !tmp_2 ))) end end;
            (if
            (#"/home/work/workspace/self/verker/strcasecmp.c" 20 10 18#
            (Unsafe_int32.(=)  !c1 !c2 ))
            then
             (if
             (#"/home/work/workspace/self/verker/strcasecmp.c" 20 22 29#
             (Unsafe_int32.(<>)  !c1
              (#"strcasecmp.jc" 492 63 75# "expl:Integer cast"
              (Unsafe_int32.of_int (0))) )) then ()
             else (raise (Goto_while_0_break_exc ())))
            else (raise (Goto_while_0_break_exc ()))) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end end with Goto_while_0_break_exc _jessie_1 ->
      'While_0_break:
      'While_0_break:
      begin
      ();
       begin
       (res := (Unsafe_int32.(-)  !c1 !c2 ));
        begin
        (assert {
        (#"/home/work/workspace/self/verker/strcasecmp.c" 22 12 44#
        "expl:Assertion in line 22"
        ((Int32.(=) !c1 !c2) ->
         ((Int32.(=) !c1 (#"strcasecmp.jc" 502 60 72# "expl:Integer cast"
          (Int32.of_int (0))))
         /\
         (Int32.(=) !res (#"strcasecmp.jc" 503 62 74# "expl:Integer cast"
         (Int32.of_int (0))))))) }); () end;
        begin
        (assert {
        (#"/home/work/workspace/self/verker/strcasecmp.c" 23 12 289#
        "expl:Assertion in line 23"
        ((Int32.(<>) !c1 !c2) ->
         (exists i_10 : int.
          (((<=) (0) i_10) /\
          (((<=) i_10 (Uint64.to_int (strlen !os1 charP_charM_s1_5))) /\
          ((forall j_0 : int.
            ((((<=) (0) j_0) /\ ((<) j_0 i_10)) ->
             ((=)
             (tolower
             (Int8.to_int (select charP_charM_s1_5 (shift !os1 j_0))))
             (tolower
             (Int8.to_int (select charP_charM_s2_6 (shift !os2 j_0)))))))
          /\
          (((<>)
           (tolower
           (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_10))))
           (tolower
           (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_10)))))
          /\
          (((=) (Int32.to_int !res)
           (Int.(-)
           (tolower
           (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_10))))
           (tolower
           (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_10))))))
          /\ ((=) i_10 (Int.(-) (sub_pointer !mutable_s1 !os1) (1)))))))))))
        }); () end;
        begin
        (__retres := (Unsafe_int32.(-)  !c1 !c2 ));
         begin (return := !__retres); (raise Return) end end end end end))))))))));
     absurd  end with Return -> !return end)))
  
  let strcasecmp_ensures_equal
  #"/home/work/workspace/self/verker/strcasecmp.c" 3 4 46#
  "expl:Function strcasecmp, behavior equal" =
  fun
   (s1 : (pointer voidP)) (s2 : (pointer voidP)) (voidP_s1_5_alloc_table :
   (alloc_table voidP)) (voidP_s2_6_alloc_table : (alloc_table voidP))
   (voidP_s2_6_tag_table : (tag_table voidP)) (voidP_s1_5_tag_table :
   (tag_table voidP)) (charP_charM_s1_5 : (memory voidP Int8.t))
   (charP_charM_s2_6 : (memory voidP Int8.t)) 
   requires {
   ((forall i_8 : int.
     ((((<=) (0) i_8) /\
      ((<=) i_8 (Uint64.to_int (strlen s1 charP_charM_s1_5)))) ->
      ((=) (tolower (Int8.to_int (select charP_charM_s1_5 (shift s1 i_8))))
      (tolower (Int8.to_int (select charP_charM_s2_6 (shift s2 i_8)))))))
   /\
   (((allocated voidP_s2_6_alloc_table s2) ->
     (((=) (typeof voidP_s2_6_tag_table s2) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s2_6_alloc_table s2) i) /\
       ((<) i (offset_max voidP_s2_6_alloc_table s2))) ->
       ((=) (typeof voidP_s2_6_tag_table (shift s2 i)) charP_tag)))))
   /\
   (((allocated voidP_s1_5_alloc_table s1) ->
     (((=) (typeof voidP_s1_5_tag_table s1) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s1_5_alloc_table s1) i) /\
       ((<) i (offset_max voidP_s1_5_alloc_table s1))) ->
       ((=) (typeof voidP_s1_5_tag_table (shift s1 i)) charP_tag)))))
   /\
   (#"strcasecmp.jc" 355 12 76#
   ((#"/home/work/workspace/self/verker/strcasecmp.h" 8 13 26#
    (valid_str s1 voidP_s1_5_alloc_table charP_charM_s1_5))
   /\
   (#"/home/work/workspace/self/verker/strcasecmp.h" 9 13 26#
   (valid_str s2 voidP_s2_6_alloc_table charP_charM_s2_6))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/self/verker/strcasecmp.h" 13 15 27#
     "expl:Ensures clause"
     (Int32.(=) result (#"strcasecmp.jc" 364 32 44# "expl:Integer cast"
     (Int32.of_int (0)))))) } diverges  ->
   (let mutable_s1 = ref s1 in
   (let mutable_s2 = ref s2 in
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); ();
     (let c1 = ref (Unsafe_int32.any_  () ) in
     (let c2 = ref (Unsafe_int32.any_  () ) in
     (let os1 = ref (any_pointer  () : (pointer voidP)) in
     (let os2 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (Unsafe_int8.any_  () ) in
     (let tmp_1 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_2 = ref (Unsafe_int8.any_  () ) in
     (let res = ref (Unsafe_int32.any_  () ) in
     (let __retres = ref (Unsafe_int32.any_  () ) in
     try
      begin
      (os1 := !mutable_s1);
       begin
       (os2 := !mutable_s2);
        'Loop_2:
        loop
        invariant { (#"strcasecmp.jc" 432 6 3008# true) } 
         begin
         any unit
         requires { true } reads { mutable_s1, mutable_s2 }
         ensures {
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 13 20 115#
            (forall i_9 : int.
             ((((<=) (0) i_9) /\ ((<) i_9 (sub_pointer !mutable_s1 !os1))) ->
              ((=)
              (tolower
              (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_9))))
              (tolower
              (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_9))))))))
           /\
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 12 20 40#
            ((=) (sub_pointer !mutable_s1 !os1)
            (sub_pointer !mutable_s2 !os2)))
           /\
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 29#
             (same_block !os2 !mutable_s2))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 29#
             ((<=) (sub_pointer !os2 !mutable_s2) (0)))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 27 50#
             (same_block !mutable_s2
             (shift !os2 (Uint64.to_int (strlen !os2 charP_charM_s2_6)))))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 27 50#
            ((<=)
            (sub_pointer !mutable_s2
            (shift !os2 (Uint64.to_int (strlen !os2 charP_charM_s2_6)))) (0))))))))))
           /\
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 29#
             (same_block !os1 !mutable_s1))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 29#
             ((<=) (sub_pointer !os1 !mutable_s1) (0)))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 27 50#
             (same_block !mutable_s1
             (shift !os1 (Uint64.to_int (strlen !os1 charP_charM_s1_5)))))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 27 50#
            ((<=)
            (sub_pointer !mutable_s1
            (shift !os1 (Uint64.to_int (strlen !os1 charP_charM_s1_5)))) (0))))))))))
           /\
           (#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 50#
           (#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 50#
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 33#
            (valid_str !mutable_s1 voidP_s1_5_alloc_table charP_charM_s1_5))
           /\
           (#"/home/work/workspace/self/verker/strcasecmp.c" 9 37 50#
           (valid_str !mutable_s2 voidP_s2_6_alloc_table charP_charM_s2_6)))))))))
           } ;
          try
           begin
           begin
           begin
           begin
           begin
           begin
           (tmp := !mutable_s1);
            begin
            (mutable_s1 :=
             (shift_  !mutable_s1
              (Unsafe_int32.to_int 
               (#"strcasecmp.jc" 473 54 66# "expl:Integer cast"
               (Unsafe_int32.of_int (1))) ) )); () end end;
            (tmp_0 :=
             (let _jessie_23 = (acc  charP_charM_s1_5 !tmp ) in
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 7 21#
             "expl:Precondition for tolower"
             (Function_tolower_0.tolower_0  _jessie_23 )))) end;
            (c1 :=
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 7 21#
             "expl:Integer cast" (Unsafe_int32_of_Unsafe_int8.cast  !tmp_0 )))
           end;
            begin
            begin
            begin
            (tmp_1 := !mutable_s2);
             begin
             (mutable_s2 :=
              (shift_  !mutable_s2
               (Unsafe_int32.to_int 
                (#"strcasecmp.jc" 484 54 66# "expl:Integer cast"
                (Unsafe_int32.of_int (1))) ) )); () end end;
             (tmp_2 :=
              (let _jessie_28 = (acc  charP_charM_s2_6 !tmp_1 ) in
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 7 21#
              "expl:Precondition for tolower"
              (Function_tolower_0.tolower_0  _jessie_28 )))) end;
             (c2 :=
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 7 21#
              "expl:Integer cast"
              (Unsafe_int32_of_Unsafe_int8.cast  !tmp_2 ))) end end;
            (if
            (#"/home/work/workspace/self/verker/strcasecmp.c" 20 10 18#
            (Unsafe_int32.(=)  !c1 !c2 ))
            then
             (if
             (#"/home/work/workspace/self/verker/strcasecmp.c" 20 22 29#
             (Unsafe_int32.(<>)  !c1
              (#"strcasecmp.jc" 492 63 75# "expl:Integer cast"
              (Unsafe_int32.of_int (0))) )) then ()
             else (raise (Goto_while_0_break_exc ())))
            else (raise (Goto_while_0_break_exc ()))) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end end with Goto_while_0_break_exc _jessie_1 ->
      'While_0_break:
      'While_0_break:
      begin
      ();
       begin
       (res := (Unsafe_int32.(-)  !c1 !c2 ));
        begin
        any unit
        requires { true }
        ensures {
          (#"/home/work/workspace/self/verker/strcasecmp.c" 22 12 44#
          ((Int32.(=) !c1 !c2) ->
           ((Int32.(=) !c1 (#"strcasecmp.jc" 502 60 72# "expl:Integer cast"
            (Int32.of_int (0))))
           /\
           (Int32.(=) !res (#"strcasecmp.jc" 503 62 74# "expl:Integer cast"
           (Int32.of_int (0))))))) } ; () end;
        begin
        any unit
        requires { true } reads { mutable_s1 }
        ensures {
          (#"/home/work/workspace/self/verker/strcasecmp.c" 23 12 289#
          ((Int32.(<>) !c1 !c2) ->
           (exists i_10 : int.
            (((<=) (0) i_10) /\
            (((<=) i_10 (Uint64.to_int (strlen !os1 charP_charM_s1_5))) /\
            ((forall j_0 : int.
              ((((<=) (0) j_0) /\ ((<) j_0 i_10)) ->
               ((=)
               (tolower
               (Int8.to_int (select charP_charM_s1_5 (shift !os1 j_0))))
               (tolower
               (Int8.to_int (select charP_charM_s2_6 (shift !os2 j_0)))))))
            /\
            (((<>)
             (tolower
             (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_10))))
             (tolower
             (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_10)))))
            /\
            (((=) (Int32.to_int !res)
             (Int.(-)
             (tolower
             (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_10))))
             (tolower
             (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_10))))))
            /\ ((=) i_10 (Int.(-) (sub_pointer !mutable_s1 !os1) (1)))))))))))
          } ; () end;
        begin
        (__retres := (Unsafe_int32.(-)  !c1 !c2 ));
         begin (return := !__retres); (raise Return) end end end end end))))))))));
     absurd  end with Return -> !return end)))
  
  let strcasecmp_ensures_not_equal
  #"/home/work/workspace/self/verker/strcasecmp.c" 3 4 46#
  "expl:Function strcasecmp, behavior not_equal" =
  fun
   (s1 : (pointer voidP)) (s2 : (pointer voidP)) (voidP_s1_5_alloc_table :
   (alloc_table voidP)) (voidP_s2_6_alloc_table : (alloc_table voidP))
   (voidP_s2_6_tag_table : (tag_table voidP)) (voidP_s1_5_tag_table :
   (tag_table voidP)) (charP_charM_s1_5 : (memory voidP Int8.t))
   (charP_charM_s2_6 : (memory voidP Int8.t)) 
   requires {
   ((exists i_6 : int.
     (((<=) (0) i_6) /\
     (((<=) i_6 (Uint64.to_int (strlen s1 charP_charM_s1_5))) /\
     ((<>) (tolower (Int8.to_int (select charP_charM_s1_5 (shift s1 i_6))))
     (tolower (Int8.to_int (select charP_charM_s2_6 (shift s2 i_6))))))))
   /\
   (((allocated voidP_s2_6_alloc_table s2) ->
     (((=) (typeof voidP_s2_6_tag_table s2) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s2_6_alloc_table s2) i) /\
       ((<) i (offset_max voidP_s2_6_alloc_table s2))) ->
       ((=) (typeof voidP_s2_6_tag_table (shift s2 i)) charP_tag)))))
   /\
   (((allocated voidP_s1_5_alloc_table s1) ->
     (((=) (typeof voidP_s1_5_tag_table s1) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s1_5_alloc_table s1) i) /\
       ((<) i (offset_max voidP_s1_5_alloc_table s1))) ->
       ((=) (typeof voidP_s1_5_tag_table (shift s1 i)) charP_tag)))))
   /\
   (#"strcasecmp.jc" 355 12 76#
   ((#"/home/work/workspace/self/verker/strcasecmp.h" 8 13 26#
    (valid_str s1 voidP_s1_5_alloc_table charP_charM_s1_5))
   /\
   (#"/home/work/workspace/self/verker/strcasecmp.h" 9 13 26#
   (valid_str s2 voidP_s2_6_alloc_table charP_charM_s2_6))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/self/verker/strcasecmp.h" 16 15 27#
     "expl:Ensures clause"
     (#"/home/work/workspace/self/verker/strcasecmp.h" 16 15 27#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker/strcasecmp.h" 16 15 27#
      "expl:Ensures clause"
      (Int32.(<>) result (#"strcasecmp.jc" 370 43 55# "expl:Integer cast"
      (Int32.of_int (0)))))
     /\
     (#"/home/work/workspace/self/verker/strcasecmp.h" 17 15 253#
     "expl:Ensures clause"
     (exists i_7 : int.
      (((<=) (0) i_7) /\
      (((<=) i_7 (Uint64.to_int (strlen s1 charP_charM_s1_5))) /\
      ((forall j : int.
        ((((<=) (0) j) /\ ((<) j i_7)) ->
         ((=) (tolower (Int8.to_int (select charP_charM_s1_5 (shift s1 j))))
         (tolower (Int8.to_int (select charP_charM_s2_6 (shift s2 j)))))))
      /\
      (((<>) (tolower (Int8.to_int (select charP_charM_s1_5 (shift s1 i_7))))
       (tolower (Int8.to_int (select charP_charM_s2_6 (shift s2 i_7)))))
      /\
      ((=) (Int32.to_int result)
      (Int.(-)
      (tolower (Int8.to_int (select charP_charM_s1_5 (shift s1 i_7))))
      (tolower (Int8.to_int (select charP_charM_s2_6 (shift s2 i_7))))))))))))))))
     } diverges  ->
   (let mutable_s1 = ref s1 in
   (let mutable_s2 = ref s2 in
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (); ();
     (let c1 = ref (Unsafe_int32.any_  () ) in
     (let c2 = ref (Unsafe_int32.any_  () ) in
     (let os1 = ref (any_pointer  () : (pointer voidP)) in
     (let os2 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (Unsafe_int8.any_  () ) in
     (let tmp_1 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_2 = ref (Unsafe_int8.any_  () ) in
     (let res = ref (Unsafe_int32.any_  () ) in
     (let __retres = ref (Unsafe_int32.any_  () ) in
     try
      begin
      (os1 := !mutable_s1);
       begin
       (os2 := !mutable_s2);
        'Loop_3:
        loop
        invariant { (#"strcasecmp.jc" 432 6 3008# true) } 
         begin
         any unit
         requires { true } reads { mutable_s1, mutable_s2 }
         ensures {
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 13 20 115#
            (forall i_9 : int.
             ((((<=) (0) i_9) /\ ((<) i_9 (sub_pointer !mutable_s1 !os1))) ->
              ((=)
              (tolower
              (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_9))))
              (tolower
              (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_9))))))))
           /\
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 12 20 40#
            ((=) (sub_pointer !mutable_s1 !os1)
            (sub_pointer !mutable_s2 !os2)))
           /\
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 29#
             (same_block !os2 !mutable_s2))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 29#
             ((<=) (sub_pointer !os2 !mutable_s2) (0)))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 11 27 50#
             (same_block !mutable_s2
             (shift !os2 (Uint64.to_int (strlen !os2 charP_charM_s2_6)))))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 11 27 50#
            ((<=)
            (sub_pointer !mutable_s2
            (shift !os2 (Uint64.to_int (strlen !os2 charP_charM_s2_6)))) (0))))))))))
           /\
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 29#
             (same_block !os1 !mutable_s1))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 29#
             ((<=) (sub_pointer !os1 !mutable_s1) (0)))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 20 50#
            ((#"/home/work/workspace/self/verker/strcasecmp.c" 10 27 50#
             (same_block !mutable_s1
             (shift !os1 (Uint64.to_int (strlen !os1 charP_charM_s1_5)))))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.c" 10 27 50#
            ((<=)
            (sub_pointer !mutable_s1
            (shift !os1 (Uint64.to_int (strlen !os1 charP_charM_s1_5)))) (0))))))))))
           /\
           (#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 50#
           (#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 50#
           ((#"/home/work/workspace/self/verker/strcasecmp.c" 9 20 33#
            (valid_str !mutable_s1 voidP_s1_5_alloc_table charP_charM_s1_5))
           /\
           (#"/home/work/workspace/self/verker/strcasecmp.c" 9 37 50#
           (valid_str !mutable_s2 voidP_s2_6_alloc_table charP_charM_s2_6)))))))))
           } ;
          try
           begin
           begin
           begin
           begin
           begin
           begin
           (tmp := !mutable_s1);
            begin
            (mutable_s1 :=
             (shift_  !mutable_s1
              (Unsafe_int32.to_int 
               (#"strcasecmp.jc" 473 54 66# "expl:Integer cast"
               (Unsafe_int32.of_int (1))) ) )); () end end;
            (tmp_0 :=
             (let _jessie_38 = (acc  charP_charM_s1_5 !tmp ) in
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 7 21#
             "expl:Precondition for tolower"
             (Function_tolower_0.tolower_0  _jessie_38 )))) end;
            (c1 :=
             (#"/home/work/workspace/self/verker/strcasecmp.c" 18 7 21#
             "expl:Integer cast" (Unsafe_int32_of_Unsafe_int8.cast  !tmp_0 )))
           end;
            begin
            begin
            begin
            (tmp_1 := !mutable_s2);
             begin
             (mutable_s2 :=
              (shift_  !mutable_s2
               (Unsafe_int32.to_int 
                (#"strcasecmp.jc" 484 54 66# "expl:Integer cast"
                (Unsafe_int32.of_int (1))) ) )); () end end;
             (tmp_2 :=
              (let _jessie_43 = (acc  charP_charM_s2_6 !tmp_1 ) in
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 7 21#
              "expl:Precondition for tolower"
              (Function_tolower_0.tolower_0  _jessie_43 )))) end;
             (c2 :=
              (#"/home/work/workspace/self/verker/strcasecmp.c" 19 7 21#
              "expl:Integer cast"
              (Unsafe_int32_of_Unsafe_int8.cast  !tmp_2 ))) end end;
            (if
            (#"/home/work/workspace/self/verker/strcasecmp.c" 20 10 18#
            (Unsafe_int32.(=)  !c1 !c2 ))
            then
             (if
             (#"/home/work/workspace/self/verker/strcasecmp.c" 20 22 29#
             (Unsafe_int32.(<>)  !c1
              (#"strcasecmp.jc" 492 63 75# "expl:Integer cast"
              (Unsafe_int32.of_int (0))) )) then ()
             else (raise (Goto_while_0_break_exc ())))
            else (raise (Goto_while_0_break_exc ()))) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_3 -> () end end end; (raise (Goto_while_0_break_exc ()))
       end end with Goto_while_0_break_exc _jessie_1 ->
      'While_0_break:
      'While_0_break:
      begin
      ();
       begin
       (res := (Unsafe_int32.(-)  !c1 !c2 ));
        begin
        any unit
        requires { true }
        ensures {
          (#"/home/work/workspace/self/verker/strcasecmp.c" 22 12 44#
          ((Int32.(=) !c1 !c2) ->
           ((Int32.(=) !c1 (#"strcasecmp.jc" 502 60 72# "expl:Integer cast"
            (Int32.of_int (0))))
           /\
           (Int32.(=) !res (#"strcasecmp.jc" 503 62 74# "expl:Integer cast"
           (Int32.of_int (0))))))) } ; () end;
        begin
        any unit
        requires { true } reads { mutable_s1 }
        ensures {
          (#"/home/work/workspace/self/verker/strcasecmp.c" 23 12 289#
          ((Int32.(<>) !c1 !c2) ->
           (exists i_10 : int.
            (((<=) (0) i_10) /\
            (((<=) i_10 (Uint64.to_int (strlen !os1 charP_charM_s1_5))) /\
            ((forall j_0 : int.
              ((((<=) (0) j_0) /\ ((<) j_0 i_10)) ->
               ((=)
               (tolower
               (Int8.to_int (select charP_charM_s1_5 (shift !os1 j_0))))
               (tolower
               (Int8.to_int (select charP_charM_s2_6 (shift !os2 j_0)))))))
            /\
            (((<>)
             (tolower
             (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_10))))
             (tolower
             (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_10)))))
            /\
            (((=) (Int32.to_int !res)
             (Int.(-)
             (tolower
             (Int8.to_int (select charP_charM_s1_5 (shift !os1 i_10))))
             (tolower
             (Int8.to_int (select charP_charM_s2_6 (shift !os2 i_10))))))
            /\ ((=) i_10 (Int.(-) (sub_pointer !mutable_s1 !os1) (1)))))))))))
          } ; () end;
        begin
        (__retres := (Unsafe_int32.(-)  !c1 !c2 ));
         begin (return := !__retres); (raise Return) end end end end end))))))))));
     absurd  end with Return -> !return end)))
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_uint8

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_uint8

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Uint8.to_int n)) }
  
end

theory Enum__bool_of_Uint8

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Enum__bool.t
  = (Enum__bool.of_int (Uint8.to_int n))
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_uint64

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_uint64

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Uint64.to_int n)) }
  
end

theory Enum__bool_of_Uint64

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Enum__bool.t
  = (Enum__bool.of_int (Uint64.to_int n))
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_uint32

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_uint32

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Uint32.to_int n)) }
  
end

theory Enum__bool_of_Uint32

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Enum__bool.t
  = (Enum__bool.of_int (Uint32.to_int n))
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_uint16

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_uint16

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Uint16.to_int n)) }
  
end

theory Enum__bool_of_Uint16

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Enum__bool.t
  = (Enum__bool.of_int (Uint16.to_int n))
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_int8

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_int8

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Int8.to_int n)) }
  
end

theory Enum__bool_of_Int8

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Enum__bool.t
  = (Enum__bool.of_int (Int8.to_int n))
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_int64

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_int64

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Int64.to_int n)) }
  
end

theory Enum__bool_of_Int64

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Enum__bool.t
  = (Enum__bool.of_int (Int64.to_int n))
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_enum__bool_of_Safe_int32

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_int32

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Int32.to_int n)) }
  
end

theory Enum__bool_of_Int32

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Enum__bool.t
  = (Enum__bool.of_int (Int32.to_int n))
  
end

module Safe_enum__bool_of_Safe_int16

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Enum__bool.t
   requires { (Enum__bool.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Enum__bool.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_enum__bool_of_Unsafe_int16

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Enum__bool.t
   requires { true }
   ensures { ((=) (Enum__bool.to_int result) (Int16.to_int n)) }
  
end

theory Enum__bool_of_Int16

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Enum__bool.t
  = (Enum__bool.of_int (Int16.to_int n))
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_uint8_of_Safe_enum__bool

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_enum__bool

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Enum__bool.to_int n)) }
  
end

theory Uint8_of_Enum__bool

  use enum.Uint8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Uint8.t
  = (Uint8.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_uint64_of_Safe_enum__bool

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_enum__bool

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Enum__bool.to_int n)) }
  
end

theory Uint64_of_Enum__bool

  use enum.Uint64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Uint64.t
  = (Uint64.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_uint32_of_Safe_enum__bool

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_enum__bool

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Enum__bool.to_int n)) }
  
end

theory Uint32_of_Enum__bool

  use enum.Uint32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Uint32.t
  = (Uint32.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_uint16_of_Safe_enum__bool

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_enum__bool

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Enum__bool.to_int n)) }
  
end

theory Uint16_of_Enum__bool

  use enum.Uint16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Uint16.t
  = (Uint16.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_int8_of_Safe_enum__bool

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int8.t
   requires { true }
   ensures { ((=) (Int8.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_enum__bool

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int8.t
   requires { true }
   ensures { ((=) (Int8.to_int result) (Enum__bool.to_int n)) }
  
end

theory Int8_of_Enum__bool

  use enum.Int8 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Int8.t
  = (Int8.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_int64_of_Safe_enum__bool

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_enum__bool

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Enum__bool.to_int n)) }
  
end

theory Int64_of_Enum__bool

  use enum.Int64 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Int64.t
  = (Int64.of_int (Enum__bool.to_int n))
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Safe_int32_of_Safe_enum__bool

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_enum__bool

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Enum__bool.to_int n)) }
  
end

theory Int32_of_Enum__bool

  use enum.Int32 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Int32.t
  = (Int32.of_int (Enum__bool.to_int n))
  
end

module Safe_int16_of_Safe_enum__bool

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Enum__bool.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_enum__bool

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Enum__bool.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Enum__bool.to_int n)) }
  
end

theory Int16_of_Enum__bool

  use enum.Int16 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  function cast (n : Enum__bool.t) : Int16.t
  = (Int16.of_int (Enum__bool.to_int n))
  
end

module Function_strlen_0

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_4 : (memory voidP Int8.t)) : Uint64.t
     requires { true }
     ensures {
       (#"/home/work/workspace/self/verker/strlen.h" 82 12 32#
       "expl:Ensures clause"
       (#"/home/work/workspace/self/verker/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker/strlen.h" 82 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_4)))
       /\
       (#"/home/work/workspace/self/verker/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker/strlen.h" 83 12 30#
        "expl:Ensures clause"
        (Int8.(=) (select charP_charM_s_4 (shift s_0 (Uint64.to_int result)))
        (#"strcasecmp.jc" 122 33 44# "expl:Integer cast" (Int8.of_int (0)))))
       /\
       (#"/home/work/workspace/self/verker/strlen.h" 84 12 64#
       "expl:Ensures clause"
       (forall i_5 : int.
        ((((<=) (0) i_5) /\ ((<) i_5 (Uint64.to_int result))) ->
         (Int8.(<>) (select charP_charM_s_4 (shift s_0 i_5))
         (#"strcasecmp.jc" 126 65 76# "expl:Integer cast" (Int8.of_int (0))))))))))))
       }
  
end

module Function_strlen_0_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_4 : (memory voidP Int8.t)) : Uint64.t
     requires {
       ("expl:External"
       (#"/home/work/workspace/self/verker/strlen.h" 80 13 25#
       "expl:Requires clause"
       (valid_str s_0 voidP_s_4_alloc_table charP_charM_s_4))) }
     ensures {
       (#"/home/work/workspace/self/verker/strlen.h" 82 12 32#
       "expl:Ensures clause"
       (#"/home/work/workspace/self/verker/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker/strlen.h" 82 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_4)))
       /\
       (#"/home/work/workspace/self/verker/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker/strlen.h" 83 12 30#
        "expl:Ensures clause"
        (Int8.(=) (select charP_charM_s_4 (shift s_0 (Uint64.to_int result)))
        (#"strcasecmp.jc" 122 33 44# "expl:Integer cast" (Int8.of_int (0)))))
       /\
       (#"/home/work/workspace/self/verker/strlen.h" 84 12 64#
       "expl:Ensures clause"
       (forall i_5 : int.
        ((((<=) (0) i_5) /\ ((<) i_5 (Uint64.to_int result))) ->
         (Int8.(<>) (select charP_charM_s_4 (shift s_0 i_5))
         (#"strcasecmp.jc" 126 65 76# "expl:Integer cast" (Int8.of_int (0))))))))))))
       }
  
end

module Function_isalnum_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isalnum_0
  (c_2_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 77 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isalnum (Int8.to_int c_2_0)))) }
  
end

module Function_isalnum_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isalnum_0
  (c_2_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 77 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isalnum (Int8.to_int c_2_0)))) }
  
end

module Function_isalpha_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isalpha_0
  (c_3_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 79 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isalpha (Int8.to_int c_3_0)))) }
  
end

module Function_isalpha_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isalpha_0
  (c_3_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 79 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isalpha (Int8.to_int c_3_0)))) }
  
end

module Function_islower_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val islower_0
  (c_6_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 83 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (islower (Int8.to_int c_6_0)))) }
  
end

module Function_islower_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val islower_0
  (c_6_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 83 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (islower (Int8.to_int c_6_0)))) }
  
end

module Function_isspace_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isspace_0
  (c_8_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 87 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isspace (Int8.to_int c_8_0)))) }
  
end

module Function_isspace_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isspace_0
  (c_8_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 87 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isspace (Int8.to_int c_8_0)))) }
  
end

module Function_isupper_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isupper_0
  (c_9 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 89 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <-> (isupper (Int8.to_int c_9))))
     }
  
end

module Function_isupper_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isupper_0
  (c_9 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 89 12 35#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <-> (isupper (Int8.to_int c_9))))
     }
  
end

module Function_isxdigit_0

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isxdigit_0
  (c_10 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 91 12 36#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isxdigit (Int8.to_int c_10)))) }
  
end

module Function_isxdigit_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isxdigit_0
  (c_10 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 91 12 36#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     (isxdigit (Int8.to_int c_10)))) }
  
end

module Function_isascii

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val isascii
  (c_4_0 : Int8.t) : Enum__bool.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 94 12 40#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     ((Int8.(<=) (#"strcasecmp.jc" 304 23 34# "expl:Integer cast"
      (Int8.of_int (0))) c_4_0)
     /\
     (Int8.(<=) c_4_0 (#"strcasecmp.jc" 305 40 53# "expl:Integer cast"
     (Int8.of_int (127))))))) }
  
end

module Function_isascii_safe

  use enum.Int8 
  
  use import int.Int 
  
  use Enum__bool 
  
  use why3.Bool.Bool 
  
  val isascii
  (c_4_0 : Int8.t) : Enum__bool.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 94 12 40#
     "expl:Ensures clause"
     (((<>) (Enum__bool.to_int result) (0)) <->
     ((Int8.(<=) (#"strcasecmp.jc" 304 23 34# "expl:Integer cast"
      (Int8.of_int (0))) c_4_0)
     /\
     (Int8.(<=) c_4_0 (#"strcasecmp.jc" 305 40 53# "expl:Integer cast"
     (Int8.of_int (127))))))) }
  
end

module Function_isdigit_0

  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isdigit_0
  (c_5_0 : Int32.t) : Int32.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 99 12 35#
     "expl:Ensures clause"
     (((<>) (Int32.to_int result) (0)) <-> (isdigit (Int32.to_int c_5_0)))) }
  
end

module Function_isdigit_0_safe

  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isdigit_0
  (c_5_0 : Int32.t) : Int32.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 99 12 35#
     "expl:Ensures clause"
     (((<>) (Int32.to_int result) (0)) <-> (isdigit (Int32.to_int c_5_0)))) }
  
end

module Function___tolower

  use enum.Uint8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val __tolower
  (c_11 : Uint8.t) : Uint8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 102 12 33#
     "expl:Ensures clause"
     ((=) (Uint8.to_int result) (tolower (Uint8.to_int c_11)))) }
  
end

module Function___tolower_safe

  use enum.Uint8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val __tolower
  (c_11 : Uint8.t) : Uint8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 102 12 33#
     "expl:Ensures clause"
     ((=) (Uint8.to_int result) (tolower (Uint8.to_int c_11)))) }
  
end

module Function___toupper

  use enum.Uint8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val __toupper
  (c_0_0 : Uint8.t) : Uint8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 105 12 33#
     "expl:Ensures clause"
     ((=) (Uint8.to_int result) (toupper (Uint8.to_int c_0_0)))) }
  
end

module Function___toupper_safe

  use enum.Uint8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val __toupper
  (c_0_0 : Uint8.t) : Uint8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 105 12 33#
     "expl:Ensures clause"
     ((=) (Uint8.to_int result) (toupper (Uint8.to_int c_0_0)))) }
  
end

module Function_toupper_0

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val toupper_0
  (c_12 : Int8.t) : Int8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 114 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (toupper (Int8.to_int c_12)))) }
  
end

module Function_toupper_0_safe

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val toupper_0
  (c_12 : Int8.t) : Int8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 114 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (toupper (Int8.to_int c_12)))) }
  
end

module Function__tolower

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val _tolower
  (c_1_0 : Int8.t) : Int8.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 122 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (tolower (Int8.to_int c_1_0)))) }
  
end

module Function__tolower_safe

  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val _tolower
  (c_1_0 : Int8.t) : Int8.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 122 12 33#
     "expl:Ensures clause"
     ((=) (Int8.to_int result) (tolower (Int8.to_int c_1_0)))) }
  
end

module Function_isodigit_0

  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isodigit_0
  (c_7_0 : Int8.t) : Int32.t
   requires { true }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 126 12 36#
     "expl:Ensures clause"
     (((<>) (Int32.to_int result) (0)) <-> (isodigit (Int8.to_int c_7_0)))) }
  
end

module Function_isodigit_0_safe

  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val isodigit_0
  (c_7_0 : Int8.t) : Int32.t
   requires { (true) }
   ensures {
     (#"/home/work/workspace/self/verker/ctype.h" 126 12 36#
     "expl:Ensures clause"
     (((<>) (Int32.to_int result) (0)) <-> (isodigit (Int8.to_int c_7_0)))) }
  
end

module Function_strcasecmp

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val strcasecmp
  (s1 : (pointer voidP)) 
   (s2 : (pointer voidP)) 
    (voidP_s2_6_alloc_table : (alloc_table voidP)) 
     (voidP_s1_5_alloc_table : (alloc_table voidP)) 
      (voidP_s2_6_tag_table : (tag_table voidP)) 
       (voidP_s1_5_tag_table : (tag_table voidP)) 
        (charP_charM_s2_6 : (memory voidP Int8.t)) 
         (charP_charM_s1_5 : (memory voidP Int8.t)) : Int32.t
          requires { true }
          ensures {
            (((exists i_6 : int.
               (((<=) (0) i_6) /\
               (((<=) i_6 (Uint64.to_int (strlen s1 charP_charM_s1_5))) /\
               ((<>)
               (tolower
               (Int8.to_int (select charP_charM_s1_5 (shift s1 i_6))))
               (tolower
               (Int8.to_int (select charP_charM_s2_6 (shift s2 i_6)))))))) ->
              (#"/home/work/workspace/self/verker/strcasecmp.h" 16 15 27#
              "expl:Ensures clause"
              (#"/home/work/workspace/self/verker/strcasecmp.h" 16 15 27#
              "expl:Ensures clause"
              ((#"/home/work/workspace/self/verker/strcasecmp.h" 16 15 27#
               "expl:Ensures clause"
               (Int32.(<>) result (#"strcasecmp.jc" 370 43 55#
               "expl:Integer cast" (Int32.of_int (0)))))
              /\
              (#"/home/work/workspace/self/verker/strcasecmp.h" 17 15 253#
              "expl:Ensures clause"
              (exists i_7 : int.
               (((<=) (0) i_7) /\
               (((<=) i_7 (Uint64.to_int (strlen s1 charP_charM_s1_5))) /\
               ((forall j : int.
                 ((((<=) (0) j) /\ ((<) j i_7)) ->
                  ((=)
                  (tolower
                  (Int8.to_int (select charP_charM_s1_5 (shift s1 j))))
                  (tolower
                  (Int8.to_int (select charP_charM_s2_6 (shift s2 j)))))))
               /\
               (((<>)
                (tolower
                (Int8.to_int (select charP_charM_s1_5 (shift s1 i_7))))
                (tolower
                (Int8.to_int (select charP_charM_s2_6 (shift s2 i_7)))))
               /\
               ((=) (Int32.to_int result)
               (Int.(-)
               (tolower
               (Int8.to_int (select charP_charM_s1_5 (shift s1 i_7))))
               (tolower
               (Int8.to_int (select charP_charM_s2_6 (shift s2 i_7))))))))))))))))
            /\
            ((forall i_8 : int.
              ((((<=) (0) i_8) /\
               ((<=) i_8 (Uint64.to_int (strlen s1 charP_charM_s1_5)))) ->
               ((=)
               (tolower
               (Int8.to_int (select charP_charM_s1_5 (shift s1 i_8))))
               (tolower
               (Int8.to_int (select charP_charM_s2_6 (shift s2 i_8))))))) ->
             (#"/home/work/workspace/self/verker/strcasecmp.h" 13 15 27#
             "expl:Ensures clause"
             (Int32.(=) result (#"strcasecmp.jc" 364 32 44#
             "expl:Integer cast" (Int32.of_int (0))))))) }
  
end

module Function_strcasecmp_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_Ctype 
  
  use why3.Bool.Bool 
  
  val strcasecmp
  (s1 : (pointer voidP)) 
   (s2 : (pointer voidP)) 
    (voidP_s2_6_alloc_table : (alloc_table voidP)) 
     (voidP_s1_5_alloc_table : (alloc_table voidP)) 
      (voidP_s2_6_tag_table : (tag_table voidP)) 
       (voidP_s1_5_tag_table : (tag_table voidP)) 
        (charP_charM_s2_6 : (memory voidP Int8.t)) 
         (charP_charM_s1_5 : (memory voidP Int8.t)) : Int32.t
          requires {
            ("expl:Internal"
            (#"strcasecmp.jc" 355 12 76# "expl:Requires clause"
            ((#"/home/work/workspace/self/verker/strcasecmp.h" 8 13 26#
             "expl:Requires clause"
             (valid_str s1 voidP_s1_5_alloc_table charP_charM_s1_5))
            /\
            (#"/home/work/workspace/self/verker/strcasecmp.h" 9 13 26#
            "expl:Requires clause"
            (valid_str s2 voidP_s2_6_alloc_table charP_charM_s2_6))))) }
          ensures {
            (((exists i_6 : int.
               (((<=) (0) i_6) /\
               (((<=) i_6 (Uint64.to_int (strlen s1 charP_charM_s1_5))) /\
               ((<>)
               (tolower
               (Int8.to_int (select charP_charM_s1_5 (shift s1 i_6))))
               (tolower
               (Int8.to_int (select charP_charM_s2_6 (shift s2 i_6)))))))) ->
              (#"/home/work/workspace/self/verker/strcasecmp.h" 16 15 27#
              "expl:Ensures clause"
              (#"/home/work/workspace/self/verker/strcasecmp.h" 16 15 27#
              "expl:Ensures clause"
              ((#"/home/work/workspace/self/verker/strcasecmp.h" 16 15 27#
               "expl:Ensures clause"
               (Int32.(<>) result (#"strcasecmp.jc" 370 43 55#
               "expl:Integer cast" (Int32.of_int (0)))))
              /\
              (#"/home/work/workspace/self/verker/strcasecmp.h" 17 15 253#
              "expl:Ensures clause"
              (exists i_7 : int.
               (((<=) (0) i_7) /\
               (((<=) i_7 (Uint64.to_int (strlen s1 charP_charM_s1_5))) /\
               ((forall j : int.
                 ((((<=) (0) j) /\ ((<) j i_7)) ->
                  ((=)
                  (tolower
                  (Int8.to_int (select charP_charM_s1_5 (shift s1 j))))
                  (tolower
                  (Int8.to_int (select charP_charM_s2_6 (shift s2 j)))))))
               /\
               (((<>)
                (tolower
                (Int8.to_int (select charP_charM_s1_5 (shift s1 i_7))))
                (tolower
                (Int8.to_int (select charP_charM_s2_6 (shift s2 i_7)))))
               /\
               ((=) (Int32.to_int result)
               (Int.(-)
               (tolower
               (Int8.to_int (select charP_charM_s1_5 (shift s1 i_7))))
               (tolower
               (Int8.to_int (select charP_charM_s2_6 (shift s2 i_7))))))))))))))))
            /\
            ((forall i_8 : int.
              ((((<=) (0) i_8) /\
               ((<=) i_8 (Uint64.to_int (strlen s1 charP_charM_s1_5)))) ->
               ((=)
               (tolower
               (Int8.to_int (select charP_charM_s1_5 (shift s1 i_8))))
               (tolower
               (Int8.to_int (select charP_charM_s2_6 (shift s2 i_8))))))) ->
             (#"/home/work/workspace/self/verker/strcasecmp.h" 13 15 27#
             "expl:Ensures clause"
             (Int32.(=) result (#"strcasecmp.jc" 364 32 44#
             "expl:Integer cast" (Int32.of_int (0))))))) }
  
end


theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_safe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_unsafe

  use why3.Bool.Bool 
  
end

theory Axiomatic_Strlen

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate valid_str (s : (pointer voidP)) (voidP_s_2_alloc_table_at_L :
  (alloc_table voidP)) (charP_charM_s_2_at_L : (memory voidP Int8.t))
  =
     (exists n_1 : Uint64.t.
      ((Int8.(=) (select charP_charM_s_2_at_L (shift s (Uint64.to_int n_1)))
       (#"strcmp.jc" 27 42 53# "expl:Integer cast" (Int8.of_int (0))))
      /\
      (if ((<=) (0) (Uint64.to_int n_1)) then
       (((<=) (offset_min voidP_s_2_alloc_table_at_L s) (0)) /\
       (((>=) (offset_max voidP_s_2_alloc_table_at_L s) (Uint64.to_int n_1))
       /\
       (forall __framac_tmp1 : int.
        ((((<=) (0) __framac_tmp1) /\
         ((<=) __framac_tmp1 (Uint64.to_int n_1))) -> ((=) true true)))))
       else ((=) true true))))
  
  lemma Valid_str_shift1
  #"/home/work/workspace/self/verker-gh/strlen.h" 12 7 102#
  "expl:Lemma valid_str_shift1" :
  (forall voidP_s_0_7_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_0_7_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 12 7 102#
    (forall s_0_0 : (pointer voidP).
     (((Int8.(<>) (select charP_charM_s_0_7_at_L s_0_0)
       (#"strcmp.jc" 41 28 39# "expl:Integer cast" (Int8.of_int (0))))
      /\
      (valid_str s_0_0 voidP_s_0_7_alloc_table_at_L charP_charM_s_0_7_at_L))
      ->
      (valid_str (shift s_0_0 (1)) voidP_s_0_7_alloc_table_at_L
      charP_charM_s_0_7_at_L))))))
  
  lemma Valid_str_strend
  #"/home/work/workspace/self/verker-gh/strlen.h" 18 7 87#
  "expl:Lemma valid_str_strend" :
  (forall voidP_s_1_8_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_1_8_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 18 7 87#
    (forall s_1 : (pointer voidP).
     (((((<=) (offset_min voidP_s_1_8_alloc_table_at_L s_1) (0)) /\
       (((>=) (offset_max voidP_s_1_8_alloc_table_at_L s_1) (0)) /\
       ((=) true true)))
      /\
      (Int8.(=) (select charP_charM_s_1_8_at_L s_1) (#"strcmp.jc" 49 29 40#
      "expl:Integer cast" (Int8.of_int (0))))) ->
      (valid_str s_1 voidP_s_1_8_alloc_table_at_L charP_charM_s_1_8_at_L))))))
  
  function strlen (pointer voidP) (memory voidP Int8.t) :
  Uint64.t
  
  lemma Strlen_before_null
  #"/home/work/workspace/self/verker-gh/strlen.h" 26 7 106#
  "expl:Lemma strlen_before_null" :
  (forall voidP_s_3_9_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_3_9_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 26 7 106#
    (forall s_3 : (pointer voidP).
     (forall i_1 : int.
      (((valid_str s_3 voidP_s_3_9_alloc_table_at_L charP_charM_s_3_9_at_L)
       /\
       (((<=) (0) i_1) /\
       ((<) i_1 (Uint64.to_int (strlen s_3 charP_charM_s_3_9_at_L))))) ->
       (Int8.(<>) (select charP_charM_s_3_9_at_L (shift s_3 i_1))
       (#"strcmp.jc" 62 38 49# "expl:Integer cast" (Int8.of_int (0))))))))))
  
  lemma Strlen_at_null
  #"/home/work/workspace/self/verker-gh/strlen.h" 31 7 71#
  "expl:Lemma strlen_at_null" :
  (forall voidP_s_4_10_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_4_10_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 31 7 71#
    (forall s_4 : (pointer voidP).
     ((valid_str s_4 voidP_s_4_10_alloc_table_at_L charP_charM_s_4_10_at_L)
      ->
      (Int8.(=)
      (select charP_charM_s_4_10_at_L
      (shift s_4 (Uint64.to_int (strlen s_4 charP_charM_s_4_10_at_L))))
      (#"strcmp.jc" 67 60 71# "expl:Integer cast" (Int8.of_int (0)))))))))
  
  lemma Strlen_shift
  #"/home/work/workspace/self/verker-gh/strlen.h" 35 7 125#
  "expl:Lemma strlen_shift" :
  (forall voidP_s_5_11_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_5_11_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 35 7 125#
    (forall s_5 : (pointer voidP).
     (forall i_2 : Uint64.t.
      (((valid_str s_5 voidP_s_5_11_alloc_table_at_L charP_charM_s_5_11_at_L)
       /\ (Uint64.(<=) i_2 (strlen s_5 charP_charM_s_5_11_at_L))) ->
       ((=)
       (Uint64.to_int
       (strlen (shift s_5 (Uint64.to_int i_2)) charP_charM_s_5_11_at_L))
       (Int.(-) (Uint64.to_int (strlen s_5 charP_charM_s_5_11_at_L))
       (Uint64.to_int i_2)))))))))
  
  lemma Strlen_shift_ex
  #"/home/work/workspace/self/verker-gh/strlen.h" 41 7 126#
  "expl:Lemma strlen_shift_ex" :
  (forall voidP_s_6_12_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_6_12_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 41 7 126#
    (forall s_6 : (pointer voidP).
     (forall i_3 : Uint64.t.
      (((valid_str s_6 voidP_s_6_12_alloc_table_at_L charP_charM_s_6_12_at_L)
       /\
       ((Uint64.(<) (#"strcmp.jc" 79 39 52# "expl:Integer cast"
        (Uint64.of_int (0))) i_3)
       /\ (Uint64.(<=) i_3 (strlen s_6 charP_charM_s_6_12_at_L)))) ->
       (Uint64.(<)
       (strlen (shift s_6 (Uint64.to_int i_3)) charP_charM_s_6_12_at_L)
       (strlen s_6 charP_charM_s_6_12_at_L))))))))
  
  lemma Strlen_shift1
  #"/home/work/workspace/self/verker-gh/strlen.h" 47 7 103#
  "expl:Lemma strlen_shift1" :
  (forall voidP_s_7_13_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_7_13_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 47 7 103#
    (forall s_7 : (pointer voidP).
     (((valid_str s_7 voidP_s_7_13_alloc_table_at_L charP_charM_s_7_13_at_L)
      /\
      (Int8.(<>) (select charP_charM_s_7_13_at_L s_7) (#"strcmp.jc" 85 49 60#
      "expl:Integer cast" (Int8.of_int (0))))) ->
      ((=) (Uint64.to_int (strlen s_7 charP_charM_s_7_13_at_L))
      (Int.(+) (1)
      (Uint64.to_int (strlen (shift s_7 (1)) charP_charM_s_7_13_at_L)))))))))
  
  lemma Strlen_pointers
  #"/home/work/workspace/self/verker-gh/strlen.h" 52 7 254#
  "expl:Lemma strlen_pointers" :
  (forall voidP_s_8_14_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_8_14_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 52 7 254#
    (forall s_8 : (pointer voidP).
     (forall sc : (pointer voidP).
      (((valid_str s_8 voidP_s_8_14_alloc_table_at_L charP_charM_s_8_14_at_L)
       /\
       ((valid_str sc voidP_s_8_14_alloc_table_at_L charP_charM_s_8_14_at_L)
       /\
       ((same_block s_8 sc) /\
       ((same_block s_8 sc) /\
       (((<=) (sub_pointer s_8 sc) (0)) /\
       (forall i_4 : int.
        ((((<=) (0) i_4) /\ ((<=) i_4 (sub_pointer sc s_8))) ->
         (Int8.(<>) (select charP_charM_s_8_14_at_L (shift s_8 i_4))
         (#"strcmp.jc" 98 43 54# "expl:Integer cast" (Int8.of_int (0)))))))))))
       ->
       (Uint64.(<=) (strlen sc charP_charM_s_8_14_at_L)
       (strlen s_8 charP_charM_s_8_14_at_L))))))))
  
  lemma Strlen_main #"/home/work/workspace/self/verker-gh/strlen.h" 61 7 159#
  "expl:Lemma strlen_main" :
  (forall voidP_s_9_16_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_9_16_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 61 7 159#
    (forall s_9 : (pointer voidP).
     (forall n_2 : Uint64.t.
      (((valid_str s_9 voidP_s_9_16_alloc_table_at_L charP_charM_s_9_16_at_L)
       /\
       ((Int8.(=)
        (select charP_charM_s_9_16_at_L (shift s_9 (Uint64.to_int n_2)))
        (#"strcmp.jc" 105 53 64# "expl:Integer cast" (Int8.of_int (0))))
       /\
       (forall i_5 : Uint64.t.
        ((Uint64.(<) i_5 n_2) ->
         (Int8.(<>)
         (select charP_charM_s_9_16_at_L (shift s_9 (Uint64.to_int i_5)))
         (#"strcmp.jc" 108 56 67# "expl:Integer cast" (Int8.of_int (0))))))))
       -> (Uint64.(=) (strlen s_9 charP_charM_s_9_16_at_L) n_2)))))))
  
  lemma Valid_str_shiftn
  #"/home/work/workspace/self/verker-gh/strlen.h" 68 7 123#
  "expl:Lemma valid_str_shiftn" :
  (forall voidP_s_10_17_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_10_17_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 68 7 123#
    (forall s_10 : (pointer voidP).
     (forall i_6 : int.
      (((valid_str s_10 voidP_s_10_17_alloc_table_at_L
        charP_charM_s_10_17_at_L)
       /\
       (((<=) (0) i_6) /\
       ((<) i_6 (Uint64.to_int (strlen s_10 charP_charM_s_10_17_at_L))))) ->
       (valid_str (shift s_10 i_6) voidP_s_10_17_alloc_table_at_L
       charP_charM_s_10_17_at_L)))))))
  
  axiom Strlen_definition :
  (forall s_2 : (pointer voidP).
   (forall charP_charM_s_2_3_at_L : (memory voidP Int8.t)
    [(strlen s_2 charP_charM_s_2_3_at_L)] .
    ((=) (strlen s_2 charP_charM_s_2_3_at_L)
    (if
     (Int8.(=) (select charP_charM_s_2_3_at_L (shift s_2 (0)))
     (#"strcmp.jc" 53 30 41# "expl:Integer cast" (Int8.of_int (0)))) then
     (#"strcmp.jc" 53 48 61# "expl:Integer cast" (Uint64.of_int (0))) else
     (#"strcmp.jc" 53 67 255# "expl:Integer cast"
     (Uint64.of_int
     (Int.(+) (1)
     (Uint64.to_int (strlen (shift s_2 (1)) charP_charM_s_2_3_at_L)))))))))
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_while_0_break_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_strcmp_safety
#"/home/work/workspace/self/verker-gh/strcmp.c" 3 4 42# "expl:strcmp, safety"

  use enum.Uint64 
  
  use Safe_bit_uint8_of_Safe_bit_int8 
  
  use Safe_bit_uint8 
  
  use Safe_bit_int32_of_Safe_bit_uint8 
  
  use Safe_bit_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use bool.Bool 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use enum.Bit_int8 
  
  use enum.Bit_int32 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let strcmp #"/home/work/workspace/self/verker-gh/strcmp.c" 3 4 42#
  "expl:Function strcmp, safety" =
  fun
   (cs : (pointer voidP)) (ct : (pointer voidP)) (voidP_cs_5_alloc_table :
   (alloc_table voidP)) (voidP_ct_6_alloc_table : (alloc_table voidP))
   (voidP_ct_6_tag_table : (tag_table voidP)) (voidP_cs_5_tag_table :
   (tag_table voidP)) (charP_charM_cs_5 : (memory voidP Int8.t))
   (charP_charM_ct_6 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_ct_6_alloc_table ct) ->
     (((=) (typeof voidP_ct_6_tag_table ct) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_ct_6_alloc_table ct) i) /\
       ((<) i (offset_max voidP_ct_6_alloc_table ct))) ->
       ((=) (typeof voidP_ct_6_tag_table (shift ct i)) charP_tag)))))
   /\
   (((allocated voidP_cs_5_alloc_table cs) ->
     (((=) (typeof voidP_cs_5_tag_table cs) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_cs_5_alloc_table cs) i) /\
       ((<) i (offset_max voidP_cs_5_alloc_table cs))) ->
       ((=) (typeof voidP_cs_5_tag_table (shift cs i)) charP_tag)))))
   /\
   (#"strcmp.jc" 134 12 74#
   ((#"/home/work/workspace/self/verker-gh/strcmp.h" 57 13 26#
    (valid_str cs voidP_cs_5_alloc_table charP_charM_cs_5))
   /\
   (#"/home/work/workspace/self/verker-gh/strcmp.h" 58 13 26#
   (valid_str ct voidP_ct_6_alloc_table charP_charM_ct_6)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   (let mutable_cs = ref cs in
   (let mutable_ct = ref ct in
   'Init:
   (let return = ref (Safe_bit_int32.any_  () ) in
   try
    begin
    (); ();
     (let c1 = ref (Safe_bit_uint8.any_  () ) in
     (let c2 = ref (Safe_bit_uint8.any_  () ) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (any_pointer  () : (pointer voidP)) in
     (let res = ref (Safe_bit_int32.any_  () ) in
     (let tmp_1 = ref (Safe_bit_int32.any_  () ) in
     (let tmp_2 = ref (Safe_bit_int32.any_  () ) in
     (let __retres = ref (Safe_bit_int32.any_  () ) in
     try
      begin
      try
       begin
       'Loop_4:
       loop
       invariant { (#"strcmp.jc" 209 6 6713# true) }
         variant { (#"/home/work/workspace/self/verker-gh/strcmp.c" 15 18 58#
           (Int.(-)
           (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5))
           (sub_pointer !mutable_cs (at !mutable_cs 'Init)))) }
        begin
        any unit
        requires { true } reads { mutable_cs, mutable_ct }
        ensures {
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 13 20 74#
           ((=) (Uint64.to_int (strlen !mutable_cs charP_charM_cs_5))
           (Int.(-)
           (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5))
           (sub_pointer !mutable_cs (at !mutable_cs 'Init)))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 11 20 121#
           (forall i_9 : int.
            ((((<=) (0) i_9) /\
             ((<) i_9 (sub_pointer !mutable_cs (at !mutable_cs 'Init)))) ->
             (Bit_int8.(=)
             (select charP_charM_cs_5 (shift (at !mutable_cs 'Init) i_9))
             (select charP_charM_ct_6 (shift (at !mutable_ct 'Init) i_9))))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 10 20 56#
           ((=) (sub_pointer !mutable_cs (at !mutable_cs 'Init))
           (sub_pointer !mutable_ct (at !mutable_ct 'Init))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 37#
            (same_block (at !mutable_ct 'Init) !mutable_ct))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 37#
            ((<=) (sub_pointer (at !mutable_ct 'Init) !mutable_ct) (0)))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 35 74#
            (same_block !mutable_ct
            (shift (at !mutable_ct 'Init)
            (Uint64.to_int (strlen (at !mutable_ct 'Init) charP_charM_ct_6)))))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 35 74#
           ((<=)
           (sub_pointer !mutable_ct
           (shift (at !mutable_ct 'Init)
           (Uint64.to_int (strlen (at !mutable_ct 'Init) charP_charM_ct_6))))
           (0))))))))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 37#
            (same_block (at !mutable_cs 'Init) !mutable_cs))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 37#
            ((<=) (sub_pointer (at !mutable_cs 'Init) !mutable_cs) (0)))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 35 74#
            (same_block !mutable_cs
            (shift (at !mutable_cs 'Init)
            (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5)))))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 35 74#
           ((<=)
           (sub_pointer !mutable_cs
           (shift (at !mutable_cs 'Init)
           (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5))))
           (0))))))))))
          /\
          (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 50#
          (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 50#
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 33#
           (valid_str !mutable_cs voidP_cs_5_alloc_table charP_charM_cs_5))
          /\
          (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 37 50#
          (valid_str !mutable_ct voidP_ct_6_alloc_table charP_charM_ct_6))))))))))
          } ;
         try
          begin
          begin
          begin
          (tmp :=
           (let _jessie_47 = !mutable_cs in
           begin
           (assert {
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 18 46 50#
           "expl:Pointer index bounds" true) }); _jessie_47 end));
           begin
           (mutable_cs :=
            (let _jessie_48 =
            (shift_typesafe  !mutable_cs
             (Safe_bit_int32.to_int 
              (#"strcmp.jc" 254 45 57# "expl:Integer cast"
              (Safe_bit_int32.of_int_const 1)) ) ) in
            begin
            (assert {
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 18 46 50#
            "expl:Pointer index bounds" true) }); _jessie_48 end));
            (c1 :=
             (let _jessie_49 =
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 18 23 50#
             "expl:Integer cast"
             (Safe_bit_uint8_of_Safe_bit_int8.cast_modulo 
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 18 45 50#
              "expl:Pointer dereference"
              (acc  voidP_cs_5_alloc_table charP_charM_cs_5 !tmp )) )) in
             begin
             (assert {
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 18 2 50#
             "expl:Pointer index bounds" true) }); _jessie_49 end)) end end;
           begin
           (tmp_0 :=
            (let _jessie_50 = !mutable_ct in
            begin
            (assert {
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 19 46 50#
            "expl:Pointer index bounds" true) }); _jessie_50 end));
            begin
            (mutable_ct :=
             (let _jessie_51 =
             (shift_typesafe  !mutable_ct
              (Safe_bit_int32.to_int 
               (#"strcmp.jc" 259 45 57# "expl:Integer cast"
               (Safe_bit_int32.of_int_const 1)) ) ) in
             begin
             (assert {
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 19 46 50#
             "expl:Pointer index bounds" true) }); _jessie_51 end));
             (c2 :=
              (let _jessie_52 =
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 19 23 50#
              "expl:Integer cast"
              (Safe_bit_uint8_of_Safe_bit_int8.cast_modulo 
               (#"/home/work/workspace/self/verker-gh/strcmp.c" 19 45 50#
               "expl:Pointer dereference"
               (acc  voidP_ct_6_alloc_table charP_charM_ct_6 !tmp_0 )) )) in
              begin
              (assert {
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 19 2 50#
              "expl:Pointer index bounds" true) }); _jessie_52 end)) end end;
           (if
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 6 14#
           (Safe_bit_int32.(<>) 
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 6 8#
            "expl:Integer cast"
            (Safe_bit_int32_of_Safe_bit_uint8.cast  !c1 ))
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 12 14#
            "expl:Integer cast"
            (Safe_bit_int32_of_Safe_bit_uint8.cast  !c2 )) ))
           then
            begin
            (if
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 30#
            (Safe_bit_int32.(<) 
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 25#
             "expl:Integer cast"
             (Safe_bit_int32_of_Safe_bit_uint8.cast  !c1 ))
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 28 30#
             "expl:Integer cast"
             (Safe_bit_int32_of_Safe_bit_uint8.cast  !c2 )) ))
            then
             (tmp_1 :=
              (let _jessie_54 =
              (#"strcmp.jc" 264 79 92# "expl:Integer cast"
              (Safe_bit_int32.of_int  (Int.(-_)  (1) ) )) in
              begin
              (assert {
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 39#
              "expl:Pointer index bounds" true) }); _jessie_54 end))
            else
             (tmp_1 :=
              (let _jessie_53 =
              (#"strcmp.jc" 265 33 45# "expl:Integer cast"
              (Safe_bit_int32.of_int_const 1)) in
              begin
              (assert {
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 39#
              "expl:Pointer index bounds" true) }); _jessie_53 end)));
             begin
             (res :=
              (let _jessie_58 = !tmp_1 in
              begin
              (assert {
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 13 16#
              "expl:Pointer index bounds" true) }); _jessie_58 end));
              begin
              any unit
              requires { true } reads { mutable_cs, mutable_ct }
              ensures {
                (#"/home/work/workspace/self/verker-gh/strcmp.c" 22 14 307#
                (exists i_8 : int.
                 (((<=) (0) i_8) /\
                 (((<=) i_8
                  (Uint64.to_int
                  (strlen (at !mutable_cs 'Init) charP_charM_cs_5)))
                 /\
                 ((forall j_0 : int.
                   ((((<=) (0) j_0) /\ ((<) j_0 i_8)) ->
                    (Bit_int8.(=)
                    (select charP_charM_cs_5
                    (shift (at !mutable_cs 'Init) j_0))
                    (select charP_charM_ct_6
                    (shift (at !mutable_ct 'Init) j_0)))))
                 /\
                 ((Bit_int8.(<>)
                  (select charP_charM_cs_5
                  (shift (at !mutable_cs 'Init) i_8))
                  (select charP_charM_ct_6
                  (shift (at !mutable_ct 'Init) i_8)))
                 /\
                 ((if
                   (Bit_uint8.(<) (#"strcmp.jc" 287 68 173#
                   "expl:Integer cast"
                   (Bit_uint8_of_Bit_int8.cast_modulo
                   (select charP_charM_cs_5
                   (shift (at !mutable_cs 'Init) i_8))))
                   (#"strcmp.jc" 289 68 173# "expl:Integer cast"
                   (Bit_uint8_of_Bit_int8.cast_modulo
                   (select charP_charM_ct_6
                   (shift (at !mutable_ct 'Init) i_8))))) then
                   (Bit_int32.(=) !res (#"strcmp.jc" 292 65 81#
                   "expl:Integer cast" (Bit_int32.of_int (Int.(-_) (1)))))
                   else
                   (Bit_int32.(=) !res (#"strcmp.jc" 294 65 77#
                   "expl:Integer cast" (Bit_int32.of_int_const 1))))
                 /\
                 ((=) i_8
                 (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init))
                 (1)))))))))) } ; () end;
              begin
              (if
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 17#
              (Safe_bit_int32.(<) 
               (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 12#
               "expl:Integer cast"
               (Safe_bit_int32_of_Safe_bit_uint8.cast  !c1 ))
               (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 15 17#
               "expl:Integer cast"
               (Safe_bit_int32_of_Safe_bit_uint8.cast  !c2 )) ))
              then
               (tmp_2 :=
                (let _jessie_57 =
                (#"strcmp.jc" 303 82 95# "expl:Integer cast"
                (Safe_bit_int32.of_int  (Int.(-_)  (1) ) )) in
                begin
                (assert {
                (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 26#
                "expl:Pointer index bounds" true) }); _jessie_57 end))
              else
               (tmp_2 :=
                (let _jessie_56 =
                (#"strcmp.jc" 304 36 48# "expl:Integer cast"
                (Safe_bit_int32.of_int_const 1)) in
                begin
                (assert {
                (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 26#
                "expl:Pointer index bounds" true) }); _jessie_56 end)));
               begin
               (__retres :=
                (let _jessie_55 = !tmp_2 in
                begin
                (assert {
                (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 3 27#
                "expl:Pointer index bounds" true) }); _jessie_55 end));
                (raise (Return_label_exc ())) end end end end else ());
           (if
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 30 6 9#
           (Bool.notb 
            (Safe_bit_uint8.(<>)  !c1
             (#"strcmp.jc" 310 46 58# "expl:Integer cast"
             (Safe_bit_uint8.of_int_const 0)) ) ))
           then (raise (Goto_while_0_break_exc ())) else ());
           begin
           any unit
           requires { true } reads { mutable_cs, mutable_ct }
           ensures {
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 32 13 79#
             (Bit_int8.(=)
             (select charP_charM_cs_5
             (shift (at !mutable_cs 'Init)
             (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init)) (1))))
             (select charP_charM_ct_6
             (shift (at !mutable_ct 'Init)
             (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init)) (1))))))
             } ; () end end; (raise (Loop_continue_exc ())) end with
          Loop_continue_exc _jessie_4 -> () end end end;
        (raise (Goto_while_0_break_exc ())) end with Goto_while_0_break_exc
       _jessie_1 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (let _jessie_59 =
         (#"strcmp.jc" 326 27 39# "expl:Integer cast"
         (Safe_bit_int32.of_int_const 0)) in
         begin
         (assert {
         (#"/home/work/workspace/self/verker-gh/strcmp.c" 35 1 10#
         "expl:Pointer index bounds" true) }); _jessie_59 end)) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
      'Return_label:
      'Return_label:
      begin
      (return :=
       (let _jessie_60 = !__retres in
       begin
       (assert { (#"strcmp.jc" 328 7 22# "expl:Pointer index bounds" true) });
        _jessie_60 end)); (raise Return) end end)))))))); absurd  end with
    Return -> !return end)))
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Function_strcmp_behaviors
#"/home/work/workspace/self/verker-gh/strcmp.c" 3 4 42#
"expl:strcmp, behaviors"

  use Unsafe_bit_uint8_of_Unsafe_bit_int8 
  
  use Unsafe_bit_uint8 
  
  use Unsafe_bit_int32_of_Unsafe_bit_uint8 
  
  use Unsafe_bit_int32 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use bool.Bool 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use enum.Bit_int8 
  
  use enum.Bit_int32 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let strcmp_ensures_default
  #"/home/work/workspace/self/verker-gh/strcmp.c" 3 4 42#
  "expl:Function strcmp, default behavior" =
  fun
   (cs : (pointer voidP)) (ct : (pointer voidP)) (voidP_cs_5_alloc_table :
   (alloc_table voidP)) (voidP_ct_6_alloc_table : (alloc_table voidP))
   (voidP_ct_6_tag_table : (tag_table voidP)) (voidP_cs_5_tag_table :
   (tag_table voidP)) (charP_charM_cs_5 : (memory voidP Int8.t))
   (charP_charM_ct_6 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_ct_6_alloc_table ct) ->
     (((=) (typeof voidP_ct_6_tag_table ct) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_ct_6_alloc_table ct) i) /\
       ((<) i (offset_max voidP_ct_6_alloc_table ct))) ->
       ((=) (typeof voidP_ct_6_tag_table (shift ct i)) charP_tag)))))
   /\
   (((allocated voidP_cs_5_alloc_table cs) ->
     (((=) (typeof voidP_cs_5_tag_table cs) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_cs_5_alloc_table cs) i) /\
       ((<) i (offset_max voidP_cs_5_alloc_table cs))) ->
       ((=) (typeof voidP_cs_5_tag_table (shift cs i)) charP_tag)))))
   /\
   (#"strcmp.jc" 134 12 74#
   ((#"/home/work/workspace/self/verker-gh/strcmp.h" 57 13 26#
    (valid_str cs voidP_cs_5_alloc_table charP_charM_cs_5))
   /\
   (#"/home/work/workspace/self/verker-gh/strcmp.h" 58 13 26#
   (valid_str ct voidP_ct_6_alloc_table charP_charM_ct_6)))))) }
   ensures { ("expl:Postcondition" ("expl:Ensures clause" true)) } diverges 
   ->
   (let mutable_cs = ref cs in
   (let mutable_ct = ref ct in
   'Init:
   (let return = ref (Unsafe_bit_int32.any_  () ) in
   try
    begin
    (check {
    (#"strcmp.jc" 167 10 794# "expl:Behavior disjointness check"
    (not
    ((forall i_12_0 : int.
      ((((<=) (0) i_12_0) /\
       ((<=) i_12_0 (Uint64.to_int (strlen !mutable_cs charP_charM_cs_5))))
       ->
       (Bit_uint8.(=) (#"strcmp.jc" 171 41 70# "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_cs_5 (shift !mutable_cs i_12_0))))
       (#"strcmp.jc" 172 42 71# "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_ct_6 (shift !mutable_ct i_12_0)))))))
    /\
    (exists i_10_0 : int.
     (((<=) (0) i_10_0) /\
     (((<=) i_10_0 (Uint64.to_int (strlen !mutable_cs charP_charM_cs_5))) /\
     (Bit_uint8.(<>) (#"strcmp.jc" 177 42 71# "expl:Integer cast"
     (Bit_uint8_of_Bit_int8.cast_modulo
     (select charP_charM_cs_5 (shift !mutable_cs i_10_0))))
     (#"strcmp.jc" 178 43 72# "expl:Integer cast"
     (Bit_uint8_of_Bit_int8.cast_modulo
     (select charP_charM_ct_6 (shift !mutable_ct i_10_0))))))))))) });
     (check {
     (#"strcmp.jc" 180 10 717# "expl:Behavior completeness check"
     ((exists i_10_1 : int.
       (((<=) (0) i_10_1) /\
       (((<=) i_10_1 (Uint64.to_int (strlen !mutable_cs charP_charM_cs_5)))
       /\
       (Bit_uint8.(<>) (#"strcmp.jc" 183 38 67# "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_cs_5 (shift !mutable_cs i_10_1))))
       (#"strcmp.jc" 184 39 68# "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_ct_6 (shift !mutable_ct i_10_1))))))))
     \/
     (forall i_12_1 : int.
      ((((<=) (0) i_12_1) /\
       ((<=) i_12_1 (Uint64.to_int (strlen !mutable_cs charP_charM_cs_5))))
       ->
       (Bit_uint8.(=) (#"strcmp.jc" 189 39 68# "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_cs_5 (shift !mutable_cs i_12_1))))
       (#"strcmp.jc" 190 40 69# "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_ct_6 (shift !mutable_ct i_12_1))))))))) });
     (let c1 = ref (Unsafe_bit_uint8.any_  () ) in
     (let c2 = ref (Unsafe_bit_uint8.any_  () ) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (any_pointer  () : (pointer voidP)) in
     (let res = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_1 = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_2 = ref (Unsafe_bit_int32.any_  () ) in
     (let __retres = ref (Unsafe_bit_int32.any_  () ) in
     try
      begin
      try
       begin
       'Loop_1:
       loop
       invariant
         { ((#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 50#
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 50#
            ((#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 33#
             (valid_str !mutable_cs voidP_cs_5_alloc_table charP_charM_cs_5))
            /\
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 37 50#
            (valid_str !mutable_ct voidP_ct_6_alloc_table charP_charM_ct_6)))))
           &&
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
            ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 37#
             (same_block (at !mutable_cs 'Init) !mutable_cs))
            /\
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
            ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 37#
             ((<=) (sub_pointer (at !mutable_cs 'Init) !mutable_cs) (0)))
            /\
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
            ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 35 74#
             (same_block !mutable_cs
             (shift (at !mutable_cs 'Init)
             (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5)))))
            /\
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 35 74#
            ((<=)
            (sub_pointer !mutable_cs
            (shift (at !mutable_cs 'Init)
            (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5))))
            (0))))))))))
           &&
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
            ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 37#
             (same_block (at !mutable_ct 'Init) !mutable_ct))
            /\
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
            ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 37#
             ((<=) (sub_pointer (at !mutable_ct 'Init) !mutable_ct) (0)))
            /\
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
            ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 35 74#
             (same_block !mutable_ct
             (shift (at !mutable_ct 'Init)
             (Uint64.to_int (strlen (at !mutable_ct 'Init) charP_charM_ct_6)))))
            /\
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 35 74#
            ((<=)
            (sub_pointer !mutable_ct
            (shift (at !mutable_ct 'Init)
            (Uint64.to_int (strlen (at !mutable_ct 'Init) charP_charM_ct_6))))
            (0))))))))))
           &&
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 10 20 56#
            ((=) (sub_pointer !mutable_cs (at !mutable_cs 'Init))
            (sub_pointer !mutable_ct (at !mutable_ct 'Init))))
           &&
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 11 20 121#
            (forall i_9 : int.
             ((((<=) (0) i_9) /\
              ((<) i_9 (sub_pointer !mutable_cs (at !mutable_cs 'Init)))) ->
              (Bit_int8.(=)
              (select charP_charM_cs_5 (shift (at !mutable_cs 'Init) i_9))
              (select charP_charM_ct_6 (shift (at !mutable_ct 'Init) i_9))))))
           &&
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 13 20 74#
           ((=) (Uint64.to_int (strlen !mutable_cs charP_charM_cs_5))
           (Int.(-)
           (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5))
           (sub_pointer !mutable_cs (at !mutable_cs 'Init)))))))))) } 
         
        begin
        any unit requires { true } ensures { true } ;
         try
          begin
          begin
          begin
          (tmp := !mutable_cs);
           begin
           (mutable_cs :=
            (shift_  !mutable_cs
             (Unsafe_bit_int32.to_int 
              (#"strcmp.jc" 254 45 57# "expl:Integer cast"
              (Unsafe_bit_int32.of_int_const 1)) ) ));
            (c1 :=
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 18 23 50#
             "expl:Integer cast"
             (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
              (acc  charP_charM_cs_5 !tmp ) ))) end end;
           begin
           (tmp_0 := !mutable_ct);
            begin
            (mutable_ct :=
             (shift_  !mutable_ct
              (Unsafe_bit_int32.to_int 
               (#"strcmp.jc" 259 45 57# "expl:Integer cast"
               (Unsafe_bit_int32.of_int_const 1)) ) ));
             (c2 :=
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 19 23 50#
              "expl:Integer cast"
              (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
               (acc  charP_charM_ct_6 !tmp_0 ) ))) end end;
           (if
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 6 14#
           (Unsafe_bit_int32.(<>) 
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 6 8#
            "expl:Integer cast"
            (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 12 14#
            "expl:Integer cast"
            (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
           then
            begin
            (if
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 30#
            (Unsafe_bit_int32.(<) 
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 25#
             "expl:Integer cast"
             (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 28 30#
             "expl:Integer cast"
             (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
            then
             (tmp_1 :=
              (#"strcmp.jc" 264 79 92# "expl:Integer cast"
              (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
            else
             (tmp_1 :=
              (#"strcmp.jc" 265 33 45# "expl:Integer cast"
              (Unsafe_bit_int32.of_int_const 1))));
             begin
             (res := !tmp_1);
              begin
              (assert {
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 22 14 307#
              "expl:Assertion in line 22"
              (exists i_8 : int.
               (((<=) (0) i_8) /\
               (((<=) i_8
                (Uint64.to_int
                (strlen (at !mutable_cs 'Init) charP_charM_cs_5)))
               /\
               ((forall j_0 : int.
                 ((((<=) (0) j_0) /\ ((<) j_0 i_8)) ->
                  (Bit_int8.(=)
                  (select charP_charM_cs_5
                  (shift (at !mutable_cs 'Init) j_0))
                  (select charP_charM_ct_6
                  (shift (at !mutable_ct 'Init) j_0)))))
               /\
               ((Bit_int8.(<>)
                (select charP_charM_cs_5 (shift (at !mutable_cs 'Init) i_8))
                (select charP_charM_ct_6 (shift (at !mutable_ct 'Init) i_8)))
               /\
               ((if
                 (Bit_uint8.(<) (#"strcmp.jc" 287 68 173# "expl:Integer cast"
                 (Bit_uint8_of_Bit_int8.cast_modulo
                 (select charP_charM_cs_5 (shift (at !mutable_cs 'Init) i_8))))
                 (#"strcmp.jc" 289 68 173# "expl:Integer cast"
                 (Bit_uint8_of_Bit_int8.cast_modulo
                 (select charP_charM_ct_6 (shift (at !mutable_ct 'Init) i_8)))))
                 then
                 (Bit_int32.(=) !res (#"strcmp.jc" 292 65 81#
                 "expl:Integer cast" (Bit_int32.of_int (Int.(-_) (1))))) else
                 (Bit_int32.(=) !res (#"strcmp.jc" 294 65 77#
                 "expl:Integer cast" (Bit_int32.of_int_const 1))))
               /\
               ((=) i_8
               (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init)) (1))))))))))
              }); () end;
              begin
              (if
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 17#
              (Unsafe_bit_int32.(<) 
               (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 12#
               "expl:Integer cast"
               (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
               (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 15 17#
               "expl:Integer cast"
               (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
              then
               (tmp_2 :=
                (#"strcmp.jc" 303 82 95# "expl:Integer cast"
                (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
              else
               (tmp_2 :=
                (#"strcmp.jc" 304 36 48# "expl:Integer cast"
                (Unsafe_bit_int32.of_int_const 1))));
               begin (__retres := !tmp_2); (raise (Return_label_exc ())) end
              end end end else ());
           (if
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 30 6 9#
           (Bool.notb 
            (Unsafe_bit_uint8.(<>)  !c1
             (#"strcmp.jc" 310 46 58# "expl:Integer cast"
             (Unsafe_bit_uint8.of_int_const 0)) ) ))
           then (raise (Goto_while_0_break_exc ())) else ());
           begin
           (assert {
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 32 13 79#
           "expl:Assertion in line 32"
           (Bit_int8.(=)
           (select charP_charM_cs_5
           (shift (at !mutable_cs 'Init)
           (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init)) (1))))
           (select charP_charM_ct_6
           (shift (at !mutable_ct 'Init)
           (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init)) (1))))))
           }); () end end; (raise (Loop_continue_exc ())) end with
          Loop_continue_exc _jessie_4 -> () end end end;
        (raise (Goto_while_0_break_exc ())) end with Goto_while_0_break_exc
       _jessie_1 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (#"strcmp.jc" 326 27 39# "expl:Integer cast"
         (Unsafe_bit_int32.of_int_const 0))) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))))))));
     absurd  end with Return -> !return end)))
  
  let strcmp_ensures_equal
  #"/home/work/workspace/self/verker-gh/strcmp.c" 3 4 42#
  "expl:Function strcmp, behavior equal" =
  fun
   (cs : (pointer voidP)) (ct : (pointer voidP)) (voidP_cs_5_alloc_table :
   (alloc_table voidP)) (voidP_ct_6_alloc_table : (alloc_table voidP))
   (voidP_ct_6_tag_table : (tag_table voidP)) (voidP_cs_5_tag_table :
   (tag_table voidP)) (charP_charM_cs_5 : (memory voidP Int8.t))
   (charP_charM_ct_6 : (memory voidP Int8.t)) 
   requires {
   ((forall i_12 : int.
     ((((<=) (0) i_12) /\
      ((<=) i_12 (Uint64.to_int (strlen cs charP_charM_cs_5)))) ->
      (Bit_uint8.(=) (#"strcmp.jc" 141 15 44# "expl:Integer cast"
      (Bit_uint8_of_Bit_int8.cast_modulo
      (select charP_charM_cs_5 (shift cs i_12)))) (#"strcmp.jc" 142 16 45#
      "expl:Integer cast"
      (Bit_uint8_of_Bit_int8.cast_modulo
      (select charP_charM_ct_6 (shift ct i_12)))))))
   /\
   (((allocated voidP_ct_6_alloc_table ct) ->
     (((=) (typeof voidP_ct_6_tag_table ct) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_ct_6_alloc_table ct) i) /\
       ((<) i (offset_max voidP_ct_6_alloc_table ct))) ->
       ((=) (typeof voidP_ct_6_tag_table (shift ct i)) charP_tag)))))
   /\
   (((allocated voidP_cs_5_alloc_table cs) ->
     (((=) (typeof voidP_cs_5_tag_table cs) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_cs_5_alloc_table cs) i) /\
       ((<) i (offset_max voidP_cs_5_alloc_table cs))) ->
       ((=) (typeof voidP_cs_5_tag_table (shift cs i)) charP_tag)))))
   /\
   (#"strcmp.jc" 134 12 74#
   ((#"/home/work/workspace/self/verker-gh/strcmp.h" 57 13 26#
    (valid_str cs voidP_cs_5_alloc_table charP_charM_cs_5))
   /\
   (#"/home/work/workspace/self/verker-gh/strcmp.h" 58 13 26#
   (valid_str ct voidP_ct_6_alloc_table charP_charM_ct_6))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/self/verker-gh/strcmp.h" 63 15 27#
     "expl:Ensures clause"
     (Bit_int32.(=) result (#"strcmp.jc" 143 31 43# "expl:Integer cast"
     (Bit_int32.of_int_const 0))))) } diverges  ->
   (let mutable_cs = ref cs in
   (let mutable_ct = ref ct in
   'Init:
   (let return = ref (Unsafe_bit_int32.any_  () ) in
   try
    begin
    (); ();
     (let c1 = ref (Unsafe_bit_uint8.any_  () ) in
     (let c2 = ref (Unsafe_bit_uint8.any_  () ) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (any_pointer  () : (pointer voidP)) in
     (let res = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_1 = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_2 = ref (Unsafe_bit_int32.any_  () ) in
     (let __retres = ref (Unsafe_bit_int32.any_  () ) in
     try
      begin
      try
       begin
       'Loop_2:
       loop
       invariant { (#"strcmp.jc" 209 6 6713# true) } 
        begin
        any unit
        requires { true } reads { mutable_cs, mutable_ct }
        ensures {
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 13 20 74#
           ((=) (Uint64.to_int (strlen !mutable_cs charP_charM_cs_5))
           (Int.(-)
           (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5))
           (sub_pointer !mutable_cs (at !mutable_cs 'Init)))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 11 20 121#
           (forall i_9 : int.
            ((((<=) (0) i_9) /\
             ((<) i_9 (sub_pointer !mutable_cs (at !mutable_cs 'Init)))) ->
             (Bit_int8.(=)
             (select charP_charM_cs_5 (shift (at !mutable_cs 'Init) i_9))
             (select charP_charM_ct_6 (shift (at !mutable_ct 'Init) i_9))))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 10 20 56#
           ((=) (sub_pointer !mutable_cs (at !mutable_cs 'Init))
           (sub_pointer !mutable_ct (at !mutable_ct 'Init))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 37#
            (same_block (at !mutable_ct 'Init) !mutable_ct))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 37#
            ((<=) (sub_pointer (at !mutable_ct 'Init) !mutable_ct) (0)))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 35 74#
            (same_block !mutable_ct
            (shift (at !mutable_ct 'Init)
            (Uint64.to_int (strlen (at !mutable_ct 'Init) charP_charM_ct_6)))))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 35 74#
           ((<=)
           (sub_pointer !mutable_ct
           (shift (at !mutable_ct 'Init)
           (Uint64.to_int (strlen (at !mutable_ct 'Init) charP_charM_ct_6))))
           (0))))))))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 37#
            (same_block (at !mutable_cs 'Init) !mutable_cs))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 37#
            ((<=) (sub_pointer (at !mutable_cs 'Init) !mutable_cs) (0)))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 35 74#
            (same_block !mutable_cs
            (shift (at !mutable_cs 'Init)
            (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5)))))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 35 74#
           ((<=)
           (sub_pointer !mutable_cs
           (shift (at !mutable_cs 'Init)
           (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5))))
           (0))))))))))
          /\
          (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 50#
          (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 50#
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 33#
           (valid_str !mutable_cs voidP_cs_5_alloc_table charP_charM_cs_5))
          /\
          (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 37 50#
          (valid_str !mutable_ct voidP_ct_6_alloc_table charP_charM_ct_6))))))))))
          } ;
         try
          begin
          begin
          begin
          (tmp := !mutable_cs);
           begin
           (mutable_cs :=
            (shift_  !mutable_cs
             (Unsafe_bit_int32.to_int 
              (#"strcmp.jc" 254 45 57# "expl:Integer cast"
              (Unsafe_bit_int32.of_int_const 1)) ) ));
            (c1 :=
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 18 23 50#
             "expl:Integer cast"
             (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
              (acc  charP_charM_cs_5 !tmp ) ))) end end;
           begin
           (tmp_0 := !mutable_ct);
            begin
            (mutable_ct :=
             (shift_  !mutable_ct
              (Unsafe_bit_int32.to_int 
               (#"strcmp.jc" 259 45 57# "expl:Integer cast"
               (Unsafe_bit_int32.of_int_const 1)) ) ));
             (c2 :=
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 19 23 50#
              "expl:Integer cast"
              (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
               (acc  charP_charM_ct_6 !tmp_0 ) ))) end end;
           (if
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 6 14#
           (Unsafe_bit_int32.(<>) 
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 6 8#
            "expl:Integer cast"
            (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 12 14#
            "expl:Integer cast"
            (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
           then
            begin
            (if
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 30#
            (Unsafe_bit_int32.(<) 
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 25#
             "expl:Integer cast"
             (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 28 30#
             "expl:Integer cast"
             (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
            then
             (tmp_1 :=
              (#"strcmp.jc" 264 79 92# "expl:Integer cast"
              (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
            else
             (tmp_1 :=
              (#"strcmp.jc" 265 33 45# "expl:Integer cast"
              (Unsafe_bit_int32.of_int_const 1))));
             begin
             (res := !tmp_1);
              begin
              any unit
              requires { true } reads { mutable_cs, mutable_ct }
              ensures {
                (#"/home/work/workspace/self/verker-gh/strcmp.c" 22 14 307#
                (exists i_8 : int.
                 (((<=) (0) i_8) /\
                 (((<=) i_8
                  (Uint64.to_int
                  (strlen (at !mutable_cs 'Init) charP_charM_cs_5)))
                 /\
                 ((forall j_0 : int.
                   ((((<=) (0) j_0) /\ ((<) j_0 i_8)) ->
                    (Bit_int8.(=)
                    (select charP_charM_cs_5
                    (shift (at !mutable_cs 'Init) j_0))
                    (select charP_charM_ct_6
                    (shift (at !mutable_ct 'Init) j_0)))))
                 /\
                 ((Bit_int8.(<>)
                  (select charP_charM_cs_5
                  (shift (at !mutable_cs 'Init) i_8))
                  (select charP_charM_ct_6
                  (shift (at !mutable_ct 'Init) i_8)))
                 /\
                 ((if
                   (Bit_uint8.(<) (#"strcmp.jc" 287 68 173#
                   "expl:Integer cast"
                   (Bit_uint8_of_Bit_int8.cast_modulo
                   (select charP_charM_cs_5
                   (shift (at !mutable_cs 'Init) i_8))))
                   (#"strcmp.jc" 289 68 173# "expl:Integer cast"
                   (Bit_uint8_of_Bit_int8.cast_modulo
                   (select charP_charM_ct_6
                   (shift (at !mutable_ct 'Init) i_8))))) then
                   (Bit_int32.(=) !res (#"strcmp.jc" 292 65 81#
                   "expl:Integer cast" (Bit_int32.of_int (Int.(-_) (1)))))
                   else
                   (Bit_int32.(=) !res (#"strcmp.jc" 294 65 77#
                   "expl:Integer cast" (Bit_int32.of_int_const 1))))
                 /\
                 ((=) i_8
                 (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init))
                 (1)))))))))) } ; () end;
              begin
              (if
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 17#
              (Unsafe_bit_int32.(<) 
               (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 12#
               "expl:Integer cast"
               (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
               (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 15 17#
               "expl:Integer cast"
               (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
              then
               (tmp_2 :=
                (#"strcmp.jc" 303 82 95# "expl:Integer cast"
                (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
              else
               (tmp_2 :=
                (#"strcmp.jc" 304 36 48# "expl:Integer cast"
                (Unsafe_bit_int32.of_int_const 1))));
               begin (__retres := !tmp_2); (raise (Return_label_exc ())) end
              end end end else ());
           (if
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 30 6 9#
           (Bool.notb 
            (Unsafe_bit_uint8.(<>)  !c1
             (#"strcmp.jc" 310 46 58# "expl:Integer cast"
             (Unsafe_bit_uint8.of_int_const 0)) ) ))
           then (raise (Goto_while_0_break_exc ())) else ());
           begin
           any unit
           requires { true } reads { mutable_cs, mutable_ct }
           ensures {
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 32 13 79#
             (Bit_int8.(=)
             (select charP_charM_cs_5
             (shift (at !mutable_cs 'Init)
             (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init)) (1))))
             (select charP_charM_ct_6
             (shift (at !mutable_ct 'Init)
             (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init)) (1))))))
             } ; () end end; (raise (Loop_continue_exc ())) end with
          Loop_continue_exc _jessie_4 -> () end end end;
        (raise (Goto_while_0_break_exc ())) end with Goto_while_0_break_exc
       _jessie_1 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (#"strcmp.jc" 326 27 39# "expl:Integer cast"
         (Unsafe_bit_int32.of_int_const 0))) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))))))));
     absurd  end with Return -> !return end)))
  
  let strcmp_ensures_not_equal
  #"/home/work/workspace/self/verker-gh/strcmp.c" 3 4 42#
  "expl:Function strcmp, behavior not_equal" =
  fun
   (cs : (pointer voidP)) (ct : (pointer voidP)) (voidP_cs_5_alloc_table :
   (alloc_table voidP)) (voidP_ct_6_alloc_table : (alloc_table voidP))
   (voidP_ct_6_tag_table : (tag_table voidP)) (voidP_cs_5_tag_table :
   (tag_table voidP)) (charP_charM_cs_5 : (memory voidP Int8.t))
   (charP_charM_ct_6 : (memory voidP Int8.t)) 
   requires {
   ((exists i_10 : int.
     (((<=) (0) i_10) /\
     (((<=) i_10 (Uint64.to_int (strlen cs charP_charM_cs_5))) /\
     (Bit_uint8.(<>) (#"strcmp.jc" 147 15 44# "expl:Integer cast"
     (Bit_uint8_of_Bit_int8.cast_modulo
     (select charP_charM_cs_5 (shift cs i_10)))) (#"strcmp.jc" 148 16 45#
     "expl:Integer cast"
     (Bit_uint8_of_Bit_int8.cast_modulo
     (select charP_charM_ct_6 (shift ct i_10))))))))
   /\
   (((allocated voidP_ct_6_alloc_table ct) ->
     (((=) (typeof voidP_ct_6_tag_table ct) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_ct_6_alloc_table ct) i) /\
       ((<) i (offset_max voidP_ct_6_alloc_table ct))) ->
       ((=) (typeof voidP_ct_6_tag_table (shift ct i)) charP_tag)))))
   /\
   (((allocated voidP_cs_5_alloc_table cs) ->
     (((=) (typeof voidP_cs_5_tag_table cs) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_cs_5_alloc_table cs) i) /\
       ((<) i (offset_max voidP_cs_5_alloc_table cs))) ->
       ((=) (typeof voidP_cs_5_tag_table (shift cs i)) charP_tag)))))
   /\
   (#"strcmp.jc" 134 12 74#
   ((#"/home/work/workspace/self/verker-gh/strcmp.h" 57 13 26#
    (valid_str cs voidP_cs_5_alloc_table charP_charM_cs_5))
   /\
   (#"/home/work/workspace/self/verker-gh/strcmp.h" 58 13 26#
   (valid_str ct voidP_ct_6_alloc_table charP_charM_ct_6))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workspace/self/verker-gh/strcmp.h" 66 15 44#
     "expl:Ensures clause"
     (#"/home/work/workspace/self/verker-gh/strcmp.h" 66 15 44#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker-gh/strcmp.h" 66 15 44#
      "expl:Ensures clause"
      ((Bit_int32.(=) result (#"strcmp.jc" 149 42 58# "expl:Integer cast"
       (Bit_int32.of_int (Int.(-_) (1)))))
      \/
      (Bit_int32.(=) result (#"strcmp.jc" 150 43 55# "expl:Integer cast"
      (Bit_int32.of_int_const 1)))))
     /\
     (#"/home/work/workspace/self/verker-gh/strcmp.h" 67 15 235#
     "expl:Ensures clause"
     (exists i_11 : int.
      (((<=) (0) i_11) /\
      (((<=) i_11 (Uint64.to_int (strlen cs charP_charM_cs_5))) /\
      ((forall j_1 : int.
        ((((<=) (0) j_1) /\ ((<) j_1 i_11)) ->
         (Bit_int8.(=) (select charP_charM_cs_5 (shift cs j_1))
         (select charP_charM_ct_6 (shift ct j_1)))))
      /\
      ((Bit_int8.(<>) (select charP_charM_cs_5 (shift cs i_11))
       (select charP_charM_ct_6 (shift ct i_11)))
      /\
      (if
       (Bit_uint8.(<) (#"strcmp.jc" 161 39 77# "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_cs_5 (shift cs i_11)))) (#"strcmp.jc" 162 40 78#
       "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_ct_6 (shift ct i_11))))) then
       (Bit_int32.(=) result (#"strcmp.jc" 164 36 52# "expl:Integer cast"
       (Bit_int32.of_int (Int.(-_) (1))))) else
       (Bit_int32.(=) result (#"strcmp.jc" 165 61 73# "expl:Integer cast"
       (Bit_int32.of_int_const 1)))))))))))))) } diverges  ->
   (let mutable_cs = ref cs in
   (let mutable_ct = ref ct in
   'Init:
   (let return = ref (Unsafe_bit_int32.any_  () ) in
   try
    begin
    (); ();
     (let c1 = ref (Unsafe_bit_uint8.any_  () ) in
     (let c2 = ref (Unsafe_bit_uint8.any_  () ) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (any_pointer  () : (pointer voidP)) in
     (let res = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_1 = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_2 = ref (Unsafe_bit_int32.any_  () ) in
     (let __retres = ref (Unsafe_bit_int32.any_  () ) in
     try
      begin
      try
       begin
       'Loop_3:
       loop
       invariant { (#"strcmp.jc" 209 6 6713# true) } 
        begin
        any unit
        requires { true } reads { mutable_cs, mutable_ct }
        ensures {
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 13 20 74#
           ((=) (Uint64.to_int (strlen !mutable_cs charP_charM_cs_5))
           (Int.(-)
           (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5))
           (sub_pointer !mutable_cs (at !mutable_cs 'Init)))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 11 20 121#
           (forall i_9 : int.
            ((((<=) (0) i_9) /\
             ((<) i_9 (sub_pointer !mutable_cs (at !mutable_cs 'Init)))) ->
             (Bit_int8.(=)
             (select charP_charM_cs_5 (shift (at !mutable_cs 'Init) i_9))
             (select charP_charM_ct_6 (shift (at !mutable_ct 'Init) i_9))))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 10 20 56#
           ((=) (sub_pointer !mutable_cs (at !mutable_cs 'Init))
           (sub_pointer !mutable_ct (at !mutable_ct 'Init))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 37#
            (same_block (at !mutable_ct 'Init) !mutable_ct))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 37#
            ((<=) (sub_pointer (at !mutable_ct 'Init) !mutable_ct) (0)))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 9 35 74#
            (same_block !mutable_ct
            (shift (at !mutable_ct 'Init)
            (Uint64.to_int (strlen (at !mutable_ct 'Init) charP_charM_ct_6)))))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 9 35 74#
           ((<=)
           (sub_pointer !mutable_ct
           (shift (at !mutable_ct 'Init)
           (Uint64.to_int (strlen (at !mutable_ct 'Init) charP_charM_ct_6))))
           (0))))))))))
          /\
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 37#
            (same_block (at !mutable_cs 'Init) !mutable_cs))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 37#
            ((<=) (sub_pointer (at !mutable_cs 'Init) !mutable_cs) (0)))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 20 74#
           ((#"/home/work/workspace/self/verker-gh/strcmp.c" 8 35 74#
            (same_block !mutable_cs
            (shift (at !mutable_cs 'Init)
            (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5)))))
           /\
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 8 35 74#
           ((<=)
           (sub_pointer !mutable_cs
           (shift (at !mutable_cs 'Init)
           (Uint64.to_int (strlen (at !mutable_cs 'Init) charP_charM_cs_5))))
           (0))))))))))
          /\
          (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 50#
          (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 50#
          ((#"/home/work/workspace/self/verker-gh/strcmp.c" 7 20 33#
           (valid_str !mutable_cs voidP_cs_5_alloc_table charP_charM_cs_5))
          /\
          (#"/home/work/workspace/self/verker-gh/strcmp.c" 7 37 50#
          (valid_str !mutable_ct voidP_ct_6_alloc_table charP_charM_ct_6))))))))))
          } ;
         try
          begin
          begin
          begin
          (tmp := !mutable_cs);
           begin
           (mutable_cs :=
            (shift_  !mutable_cs
             (Unsafe_bit_int32.to_int 
              (#"strcmp.jc" 254 45 57# "expl:Integer cast"
              (Unsafe_bit_int32.of_int_const 1)) ) ));
            (c1 :=
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 18 23 50#
             "expl:Integer cast"
             (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
              (acc  charP_charM_cs_5 !tmp ) ))) end end;
           begin
           (tmp_0 := !mutable_ct);
            begin
            (mutable_ct :=
             (shift_  !mutable_ct
              (Unsafe_bit_int32.to_int 
               (#"strcmp.jc" 259 45 57# "expl:Integer cast"
               (Unsafe_bit_int32.of_int_const 1)) ) ));
             (c2 :=
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 19 23 50#
              "expl:Integer cast"
              (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
               (acc  charP_charM_ct_6 !tmp_0 ) ))) end end;
           (if
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 6 14#
           (Unsafe_bit_int32.(<>) 
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 6 8#
            "expl:Integer cast"
            (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 20 12 14#
            "expl:Integer cast"
            (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
           then
            begin
            (if
            (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 30#
            (Unsafe_bit_int32.(<) 
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 23 25#
             "expl:Integer cast"
             (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 21 28 30#
             "expl:Integer cast"
             (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
            then
             (tmp_1 :=
              (#"strcmp.jc" 264 79 92# "expl:Integer cast"
              (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
            else
             (tmp_1 :=
              (#"strcmp.jc" 265 33 45# "expl:Integer cast"
              (Unsafe_bit_int32.of_int_const 1))));
             begin
             (res := !tmp_1);
              begin
              any unit
              requires { true } reads { mutable_cs, mutable_ct }
              ensures {
                (#"/home/work/workspace/self/verker-gh/strcmp.c" 22 14 307#
                (exists i_8 : int.
                 (((<=) (0) i_8) /\
                 (((<=) i_8
                  (Uint64.to_int
                  (strlen (at !mutable_cs 'Init) charP_charM_cs_5)))
                 /\
                 ((forall j_0 : int.
                   ((((<=) (0) j_0) /\ ((<) j_0 i_8)) ->
                    (Bit_int8.(=)
                    (select charP_charM_cs_5
                    (shift (at !mutable_cs 'Init) j_0))
                    (select charP_charM_ct_6
                    (shift (at !mutable_ct 'Init) j_0)))))
                 /\
                 ((Bit_int8.(<>)
                  (select charP_charM_cs_5
                  (shift (at !mutable_cs 'Init) i_8))
                  (select charP_charM_ct_6
                  (shift (at !mutable_ct 'Init) i_8)))
                 /\
                 ((if
                   (Bit_uint8.(<) (#"strcmp.jc" 287 68 173#
                   "expl:Integer cast"
                   (Bit_uint8_of_Bit_int8.cast_modulo
                   (select charP_charM_cs_5
                   (shift (at !mutable_cs 'Init) i_8))))
                   (#"strcmp.jc" 289 68 173# "expl:Integer cast"
                   (Bit_uint8_of_Bit_int8.cast_modulo
                   (select charP_charM_ct_6
                   (shift (at !mutable_ct 'Init) i_8))))) then
                   (Bit_int32.(=) !res (#"strcmp.jc" 292 65 81#
                   "expl:Integer cast" (Bit_int32.of_int (Int.(-_) (1)))))
                   else
                   (Bit_int32.(=) !res (#"strcmp.jc" 294 65 77#
                   "expl:Integer cast" (Bit_int32.of_int_const 1))))
                 /\
                 ((=) i_8
                 (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init))
                 (1)))))))))) } ; () end;
              begin
              (if
              (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 17#
              (Unsafe_bit_int32.(<) 
               (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 10 12#
               "expl:Integer cast"
               (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
               (#"/home/work/workspace/self/verker-gh/strcmp.c" 28 15 17#
               "expl:Integer cast"
               (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
              then
               (tmp_2 :=
                (#"strcmp.jc" 303 82 95# "expl:Integer cast"
                (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
              else
               (tmp_2 :=
                (#"strcmp.jc" 304 36 48# "expl:Integer cast"
                (Unsafe_bit_int32.of_int_const 1))));
               begin (__retres := !tmp_2); (raise (Return_label_exc ())) end
              end end end else ());
           (if
           (#"/home/work/workspace/self/verker-gh/strcmp.c" 30 6 9#
           (Bool.notb 
            (Unsafe_bit_uint8.(<>)  !c1
             (#"strcmp.jc" 310 46 58# "expl:Integer cast"
             (Unsafe_bit_uint8.of_int_const 0)) ) ))
           then (raise (Goto_while_0_break_exc ())) else ());
           begin
           any unit
           requires { true } reads { mutable_cs, mutable_ct }
           ensures {
             (#"/home/work/workspace/self/verker-gh/strcmp.c" 32 13 79#
             (Bit_int8.(=)
             (select charP_charM_cs_5
             (shift (at !mutable_cs 'Init)
             (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init)) (1))))
             (select charP_charM_ct_6
             (shift (at !mutable_ct 'Init)
             (Int.(-) (sub_pointer !mutable_cs (at !mutable_cs 'Init)) (1))))))
             } ; () end end; (raise (Loop_continue_exc ())) end with
          Loop_continue_exc _jessie_4 -> () end end end;
        (raise (Goto_while_0_break_exc ())) end with Goto_while_0_break_exc
       _jessie_1 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (#"strcmp.jc" 326 27 39# "expl:Integer cast"
         (Unsafe_bit_int32.of_int_const 0))) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))))))));
     absurd  end with Return -> !return end)))
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

theory Root_unsigned_charP

  use why3.Bool.Bool 
  
  type unsigned_charP 
  
end

theory Struct_unsigned_charP

  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function unsigned_charP_tag  : (tag_id
  unsigned_charP)
  
  axiom Unsigned_charP_parenttag_bottom :
  (parenttag unsigned_charP_tag bottom_tag)
  
  axiom Unsigned_charP_is_final :
  (forall unsigned_charP_tag_table : (tag_table unsigned_charP).
   (forall p : (pointer unsigned_charP).
    ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) ->
     ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag))))
  
  predicate frame_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_tag_table : (tag_table unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((tag_extends old_unsigned_charP_tag_table unsigned_charP_tag_table) /\
     (alloc_tag_block old_unsigned_charP_tag_table unsigned_charP_tag_table
     p))
  
  predicate frame_free_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((free_extends old_unsigned_charP_alloc_table unsigned_charP_alloc_table)
     /\
     (free_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p))
  
  predicate frame_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (n : int) (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((alloc_extends old_unsigned_charP_alloc_table
      unsigned_charP_alloc_table)
     /\
     (alloc_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p
     n))
  
  predicate fresh_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (tag_fresh unsigned_charP_tag_table p)
  
  predicate fresh_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = (alloc_fresh unsigned_charP_alloc_table p)
  
  predicate container_of_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate container_of_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate typeof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag)
  
  predicate typeof_struct_unsigned_charP (p : (pointer unsigned_charP)) (l :
  int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     (((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof unsigned_charP_tag_table (shift p i)) unsigned_charP_tag))))
  
  predicate instanceof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (instanceof unsigned_charP_tag_table p unsigned_charP_tag)
  
  predicate instanceof_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof unsigned_charP_tag_table (shift p i) unsigned_charP_tag))))
  
  predicate right_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((>=) (offset_max unsigned_charP_alloc_table p) b)
  
  predicate left_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((<=) (offset_min unsigned_charP_alloc_table p) a)
  
  predicate valid_struct_unsigned_charP (p : (pointer unsigned_charP)) (a :
  int) (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     (((<=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((>=) (offset_max unsigned_charP_alloc_table p) b))
  
  predicate strict_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (b : int) (unsigned_charP_alloc_table : (alloc_table
  unsigned_charP))
  =
     (((=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((=) (offset_max unsigned_charP_alloc_table p) b))
  
  axiom Unsigned_charP_int : ((=) (int_of_tag unsigned_charP_tag) (4))
  
end

module Struct_unsigned_charP_unsafe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !unsigned_charP_alloc_table p)) }
    writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP_requires
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { ((>=) n (0)) } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
end

module Struct_unsigned_charP_safe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires { true } writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { true } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
  val allocate_singleton_struct_unsigned_charP
  (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
   (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
    unsigned_charP)
    requires { true } writes { unsigned_charP_alloc_table,
    unsigned_charP_tag_table }
    ensures {
      ((strict_valid_struct_unsigned_charP result (0) (0)
       !unsigned_charP_alloc_table)
      /\
      ((frame_alloc_struct_unsigned_charP result (1) (old
       !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
      /\
      ((frame_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table) !unsigned_charP_tag_table)
      /\
      ((fresh_alloc_struct_unsigned_charP result (old
       !unsigned_charP_alloc_table))
      /\
      ((fresh_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table))
      /\
      ((typeof_singleton_struct_unsigned_charP result
       !unsigned_charP_tag_table)
      /\
      (container_of_singleton_struct_unsigned_charP result
      !unsigned_charP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Function_strlen_0

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_4 : (memory voidP Int8.t)) : Uint64.t
     requires { true }
     ensures {
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_4)))
       /\
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker-gh/strlen.h" 83 12 30#
        "expl:Ensures clause"
        (Int8.(=) (select charP_charM_s_4 (shift s_0 (Uint64.to_int result)))
        (#"strcmp.jc" 126 33 44# "expl:Integer cast" (Int8.of_int (0)))))
       /\
       (#"/home/work/workspace/self/verker-gh/strlen.h" 84 12 64#
       "expl:Ensures clause"
       (forall i_7 : int.
        ((((<=) (0) i_7) /\ ((<) i_7 (Uint64.to_int result))) ->
         (Int8.(<>) (select charP_charM_s_4 (shift s_0 i_7))
         (#"strcmp.jc" 130 65 76# "expl:Integer cast" (Int8.of_int (0))))))))))))
       }
  
end

module Function_strlen_0_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_4 : (memory voidP Int8.t)) : Uint64.t
     requires {
       ("expl:External"
       (#"/home/work/workspace/self/verker-gh/strlen.h" 80 13 25#
       "expl:Requires clause"
       (valid_str s_0 voidP_s_4_alloc_table charP_charM_s_4))) }
     ensures {
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_4)))
       /\
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker-gh/strlen.h" 83 12 30#
        "expl:Ensures clause"
        (Int8.(=) (select charP_charM_s_4 (shift s_0 (Uint64.to_int result)))
        (#"strcmp.jc" 126 33 44# "expl:Integer cast" (Int8.of_int (0)))))
       /\
       (#"/home/work/workspace/self/verker-gh/strlen.h" 84 12 64#
       "expl:Ensures clause"
       (forall i_7 : int.
        ((((<=) (0) i_7) /\ ((<) i_7 (Uint64.to_int result))) ->
         (Int8.(<>) (select charP_charM_s_4 (shift s_0 i_7))
         (#"strcmp.jc" 130 65 76# "expl:Integer cast" (Int8.of_int (0))))))))))))
       }
  
end

module Function_strcmp

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use enum.Bit_int8 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strcmp
  (cs : (pointer voidP)) 
   (ct : (pointer voidP)) 
    (voidP_ct_6_alloc_table : (alloc_table voidP)) 
     (voidP_cs_5_alloc_table : (alloc_table voidP)) 
      (voidP_ct_6_tag_table : (tag_table voidP)) 
       (voidP_cs_5_tag_table : (tag_table voidP)) 
        (charP_charM_ct_6 : (memory voidP Int8.t)) 
         (charP_charM_cs_5 : (memory voidP Int8.t)) : Int32.t
          requires { true }
          ensures {
            (((exists i_10 : int.
               (((<=) (0) i_10) /\
               (((<=) i_10 (Uint64.to_int (strlen cs charP_charM_cs_5))) /\
               (Bit_uint8.(<>) (#"strcmp.jc" 147 15 44# "expl:Integer cast"
               (Bit_uint8_of_Bit_int8.cast_modulo
               (select charP_charM_cs_5 (shift cs i_10))))
               (#"strcmp.jc" 148 16 45# "expl:Integer cast"
               (Bit_uint8_of_Bit_int8.cast_modulo
               (select charP_charM_ct_6 (shift ct i_10)))))))) ->
              (#"/home/work/workspace/self/verker-gh/strcmp.h" 66 15 44#
              "expl:Ensures clause"
              (#"/home/work/workspace/self/verker-gh/strcmp.h" 66 15 44#
              "expl:Ensures clause"
              ((#"/home/work/workspace/self/verker-gh/strcmp.h" 66 15 44#
               "expl:Ensures clause"
               ((Int32.(=) result (#"strcmp.jc" 149 42 58#
                "expl:Integer cast" (Int32.of_int (Int.(-_) (1)))))
               \/
               (Int32.(=) result (#"strcmp.jc" 150 43 55# "expl:Integer cast"
               (Int32.of_int (1))))))
              /\
              (#"/home/work/workspace/self/verker-gh/strcmp.h" 67 15 235#
              "expl:Ensures clause"
              (exists i_11 : int.
               (((<=) (0) i_11) /\
               (((<=) i_11 (Uint64.to_int (strlen cs charP_charM_cs_5))) /\
               ((forall j_1 : int.
                 ((((<=) (0) j_1) /\ ((<) j_1 i_11)) ->
                  (Bit_int8.(=) (select charP_charM_cs_5 (shift cs j_1))
                  (select charP_charM_ct_6 (shift ct j_1)))))
               /\
               ((Bit_int8.(<>) (select charP_charM_cs_5 (shift cs i_11))
                (select charP_charM_ct_6 (shift ct i_11)))
               /\
               (if
                (Bit_uint8.(<) (#"strcmp.jc" 161 39 77# "expl:Integer cast"
                (Bit_uint8_of_Bit_int8.cast_modulo
                (select charP_charM_cs_5 (shift cs i_11))))
                (#"strcmp.jc" 162 40 78# "expl:Integer cast"
                (Bit_uint8_of_Bit_int8.cast_modulo
                (select charP_charM_ct_6 (shift ct i_11))))) then
                (Int32.(=) result (#"strcmp.jc" 164 36 52#
                "expl:Integer cast" (Int32.of_int (Int.(-_) (1))))) else
                (Int32.(=) result (#"strcmp.jc" 165 61 73#
                "expl:Integer cast" (Int32.of_int (1)))))))))))))))
            /\
            ((forall i_12 : int.
              ((((<=) (0) i_12) /\
               ((<=) i_12 (Uint64.to_int (strlen cs charP_charM_cs_5)))) ->
               (Bit_uint8.(=) (#"strcmp.jc" 141 15 44# "expl:Integer cast"
               (Bit_uint8_of_Bit_int8.cast_modulo
               (select charP_charM_cs_5 (shift cs i_12))))
               (#"strcmp.jc" 142 16 45# "expl:Integer cast"
               (Bit_uint8_of_Bit_int8.cast_modulo
               (select charP_charM_ct_6 (shift ct i_12))))))) ->
             (#"/home/work/workspace/self/verker-gh/strcmp.h" 63 15 27#
             "expl:Ensures clause"
             (Int32.(=) result (#"strcmp.jc" 143 31 43# "expl:Integer cast"
             (Int32.of_int (0))))))) }
  
end

module Function_strcmp_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use enum.Bit_int8 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strcmp
  (cs : (pointer voidP)) 
   (ct : (pointer voidP)) 
    (voidP_ct_6_alloc_table : (alloc_table voidP)) 
     (voidP_cs_5_alloc_table : (alloc_table voidP)) 
      (voidP_ct_6_tag_table : (tag_table voidP)) 
       (voidP_cs_5_tag_table : (tag_table voidP)) 
        (charP_charM_ct_6 : (memory voidP Int8.t)) 
         (charP_charM_cs_5 : (memory voidP Int8.t)) : Int32.t
          requires {
            ("expl:Internal"
            (#"strcmp.jc" 134 12 74# "expl:Requires clause"
            ((#"/home/work/workspace/self/verker-gh/strcmp.h" 57 13 26#
             "expl:Requires clause"
             (valid_str cs voidP_cs_5_alloc_table charP_charM_cs_5))
            /\
            (#"/home/work/workspace/self/verker-gh/strcmp.h" 58 13 26#
            "expl:Requires clause"
            (valid_str ct voidP_ct_6_alloc_table charP_charM_ct_6))))) }
          ensures {
            (((exists i_10 : int.
               (((<=) (0) i_10) /\
               (((<=) i_10 (Uint64.to_int (strlen cs charP_charM_cs_5))) /\
               (Bit_uint8.(<>) (#"strcmp.jc" 147 15 44# "expl:Integer cast"
               (Bit_uint8_of_Bit_int8.cast_modulo
               (select charP_charM_cs_5 (shift cs i_10))))
               (#"strcmp.jc" 148 16 45# "expl:Integer cast"
               (Bit_uint8_of_Bit_int8.cast_modulo
               (select charP_charM_ct_6 (shift ct i_10)))))))) ->
              (#"/home/work/workspace/self/verker-gh/strcmp.h" 66 15 44#
              "expl:Ensures clause"
              (#"/home/work/workspace/self/verker-gh/strcmp.h" 66 15 44#
              "expl:Ensures clause"
              ((#"/home/work/workspace/self/verker-gh/strcmp.h" 66 15 44#
               "expl:Ensures clause"
               ((Int32.(=) result (#"strcmp.jc" 149 42 58#
                "expl:Integer cast" (Int32.of_int (Int.(-_) (1)))))
               \/
               (Int32.(=) result (#"strcmp.jc" 150 43 55# "expl:Integer cast"
               (Int32.of_int (1))))))
              /\
              (#"/home/work/workspace/self/verker-gh/strcmp.h" 67 15 235#
              "expl:Ensures clause"
              (exists i_11 : int.
               (((<=) (0) i_11) /\
               (((<=) i_11 (Uint64.to_int (strlen cs charP_charM_cs_5))) /\
               ((forall j_1 : int.
                 ((((<=) (0) j_1) /\ ((<) j_1 i_11)) ->
                  (Bit_int8.(=) (select charP_charM_cs_5 (shift cs j_1))
                  (select charP_charM_ct_6 (shift ct j_1)))))
               /\
               ((Bit_int8.(<>) (select charP_charM_cs_5 (shift cs i_11))
                (select charP_charM_ct_6 (shift ct i_11)))
               /\
               (if
                (Bit_uint8.(<) (#"strcmp.jc" 161 39 77# "expl:Integer cast"
                (Bit_uint8_of_Bit_int8.cast_modulo
                (select charP_charM_cs_5 (shift cs i_11))))
                (#"strcmp.jc" 162 40 78# "expl:Integer cast"
                (Bit_uint8_of_Bit_int8.cast_modulo
                (select charP_charM_ct_6 (shift ct i_11))))) then
                (Int32.(=) result (#"strcmp.jc" 164 36 52#
                "expl:Integer cast" (Int32.of_int (Int.(-_) (1))))) else
                (Int32.(=) result (#"strcmp.jc" 165 61 73#
                "expl:Integer cast" (Int32.of_int (1)))))))))))))))
            /\
            ((forall i_12 : int.
              ((((<=) (0) i_12) /\
               ((<=) i_12 (Uint64.to_int (strlen cs charP_charM_cs_5)))) ->
               (Bit_uint8.(=) (#"strcmp.jc" 141 15 44# "expl:Integer cast"
               (Bit_uint8_of_Bit_int8.cast_modulo
               (select charP_charM_cs_5 (shift cs i_12))))
               (#"strcmp.jc" 142 16 45# "expl:Integer cast"
               (Bit_uint8_of_Bit_int8.cast_modulo
               (select charP_charM_ct_6 (shift ct i_12))))))) ->
             (#"/home/work/workspace/self/verker-gh/strcmp.h" 63 15 27#
             "expl:Ensures clause"
             (Int32.(=) result (#"strcmp.jc" 143 31 43# "expl:Integer cast"
             (Int32.of_int (0))))))) }
  
end
